# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-06 12:02+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../../terra/summary_of_quantum_operations.rst:5
msgid "Elementary Operations"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:7
msgid ""
"In this section we will go into the different operations that are "
"available in Qiskit Terra. These are: - Single-qubit quantum gates - "
"Multi-qubit quantum gates - Measurements - Reset - Conditionals - State "
"initialization"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:12
msgid ""
"We will also show you how to use the three different simulators: - "
"unitary_simulator - qasm_simulator - statevector_simulator"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:33
msgid "Single Qubit Quantum states"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:35
msgid "A single qubit quantum state can be written as"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:37
msgid "|\\psi\\rangle = \\alpha|0\\rangle + \\beta |1\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:39
msgid ""
"where :math:`\\alpha` and :math:`\\beta` are complex numbers. In a "
"measurement the probability of the bit being in :math:`|0\\rangle` is "
":math:`|\\alpha|^2` and :math:`|1\\rangle` is :math:`|\\beta|^2`. As a "
"vector this is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:44
msgid "|\\psi\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:53
msgid ""
"Note due to conservation probability :math:`|\\alpha|^2+ |\\beta|^2 = 1` "
"and since global phase is undetectable :math:`|\\psi\\rangle := "
"e^{i\\delta} |\\psi\\rangle` we only requires two real numbers to "
"describe a single qubit quantum state."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:58
msgid "A convenient representation is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:60
msgid ""
"|\\psi\\rangle = \\cos(\\theta/2)|0\\rangle + "
"\\sin(\\theta/2)e^{i\\phi}|1\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:62
msgid ""
"where :math:`0\\leq \\phi < 2\\pi`, and :math:`0\\leq \\theta \\leq "
"\\pi`. From this it is clear that there is a one-to-one correspondence "
"between qubit states (:math:`\\mathbb{C}^2`) and the points on the "
"surface of a unit sphere (:math:`\\mathbb{R}^3`). This is called the "
"Bloch sphere representation of a qubit state."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:68
msgid ""
"Quantum gates/operations are usually represented as matrices. A gate "
"which acts on a qubit is represented by a :math:`2\\times 2` unitary "
"matrix :math:`U`. The action of the quantum gate is found by multiplying "
"the matrix representing the gate with the vector which represents the "
"quantum state."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:74
msgid "|\\psi'\\rangle = U|\\psi\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:76
msgid ""
"A general unitary must be able to take the :math:`|0\\rangle` to the "
"above state. That is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:79
msgid ""
"U = \\begin{pmatrix} \\cos(\\theta/2) & a \\\\ e^{i\\phi}\\sin(\\theta/2)"
" & b \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:87
msgid ""
"where :math:`a` and :math:`b` are complex numbers constrained such that "
":math:`U^\\dagger U = I` for all :math:`0\\leq\\theta\\leq\\pi` and "
":math:`0\\leq \\phi<2\\pi`. This gives 3 constraints and as such "
":math:`a\\rightarrow -e^{i\\lambda}\\sin(\\theta/2)` and "
":math:`b\\rightarrow e^{i\\lambda+i\\phi}\\cos(\\theta/2)` where "
":math:`0\\leq \\lambda<2\\pi` giving"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:94
msgid ""
"U = \\begin{pmatrix} \\cos(\\theta/2) & -e^{i\\lambda}\\sin(\\theta/2) "
"\\\\ e^{i\\phi}\\sin(\\theta/2) & e^{i\\lambda+i\\phi}\\cos(\\theta/2) "
"\\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:102
msgid "This is the most general form of a single qubit unitary."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:105
msgid "Single-Qubit Gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:107
msgid ""
"The single-qubit gates available are: - u gates - Identity gate - Pauli "
"gates - Clifford gates - :math:`C3` gates - Standard rotation gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:110
msgid ""
"We have provided a backend: ``unitary_simulator`` to allow you to "
"calculate the unitary matrices."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:118
msgid "u gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:120
msgid ""
"In Qiskit we give you access to the general unitary using the :math:`u3` "
"gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:123
msgid "u3(\\theta, \\phi, \\lambda) = U(\\theta, \\phi, \\lambda)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:154
msgid ""
"The :math:`u2(\\phi, \\lambda) =u3(\\pi/2, \\phi, \\lambda)` has the "
"matrix form"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:157
msgid ""
"u2(\\phi, \\lambda) = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & "
"-e^{i\\lambda} \\\\ e^{i\\phi} & e^{i(\\phi + \\lambda)} \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:166
msgid "This is a useful gate as it allows us to create superpositions"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:196
msgid "The :math:`u1(\\lambda)= u3(0, 0, \\lambda)` gate has the matrix form"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:198
msgid ""
"u1(\\lambda) = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{i \\lambda} "
"\\end{pmatrix},"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:207
msgid "which is a useful as it allows us to apply a quantum phase."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:236
msgid ""
"The :math:`u0(\\delta)= u3(0, 0, 0)` gate is the identity matrix. It has "
"the matrix form"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:239
msgid "u0(\\delta) = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:248
msgid ""
"The identity gate does nothing (but can add noise in the real device for "
"a period of time equal to fractions of the single qubit gate time)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:280
msgid "Identity gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:282
msgid "The identity gate is :math:`Id = u0(1)`."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:312
msgid "Pauli gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:315
msgid ":math:`X`: bit-flip gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:317
msgid "The bit-flip gate :math:`X` is defined as:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:319
msgid "X   = \\begin{pmatrix} 0 & 1\\\\ 1 & 0 \\end{pmatrix}= u3(\\pi,0,\\pi)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:358
msgid ":math:`Y`: bit- and phase-flip gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:360
msgid "The :math:`Y` gate is defined as:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:362
msgid ""
"Y  = \\begin{pmatrix} 0 & -i\\\\ i & 0 "
"\\end{pmatrix}=u3(\\pi,\\pi/2,\\pi/2)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:399
msgid ":math:`Z`: phase-flip gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:401
msgid "The phase flip gate :math:`Z` is defined as:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:403
msgid "Z = \\begin{pmatrix} 1 & 0\\\\ 0 & -1 \\end{pmatrix}=u1(\\pi)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:440
msgid "Clifford gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:443
msgid "Hadamard gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:445
msgid ""
"H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1\\\\ 1 & -1 "
"\\end{pmatrix}= u2(0,\\pi)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:483
msgid ":math:`S` (or, :math:`\\sqrt{Z}` phase) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:485
msgid "S = \\begin{pmatrix} 1 & 0\\\\ 0 & i \\end{pmatrix}= u1(\\pi/2)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:523
msgid ":math:`S^{\\dagger}` (or, conjugate of :math:`\\sqrt{Z}` phase) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:525
msgid ""
"S^{\\dagger} = \\begin{pmatrix} 1 & 0\\\\ 0 & -i \\end{pmatrix}= "
"u1(-\\pi/2)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:563
msgid ":math:`C3` gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:566
msgid ":math:`T` (or, :math:`\\sqrt{S}` phase) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:568
msgid "T = \\begin{pmatrix} 1 & 0\\\\ 0 & e^{i \\pi/4} \\end{pmatrix}= u1(\\pi/4)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:606
msgid ":math:`T^{\\dagger}` (or, conjugate of :math:`\\sqrt{S}` phase) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:608
msgid ""
"T^{\\dagger} = \\begin{pmatrix} 1 & 0\\\\ 0 & e^{-i \\pi/4} "
"\\end{pmatrix}= u1(-\\pi/4)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:617
msgid "They can be added as below."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:648
msgid "Standard Rotations"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:650
msgid ""
"The standard rotation gates are those that define rotations around the "
"Paulis :math:`P=\\{X,Y,Z\\}`. They are defined as"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:653
msgid ""
"R_P(\\theta) = \\exp(-i \\theta P/2) = \\cos(\\theta/2)I -i "
"\\sin(\\theta/2)P"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:656
msgid "Rotation around X-axis"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:658
msgid ""
"R_x(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) & -i\\sin(\\theta/2)\\\\"
" -i\\sin(\\theta/2) & \\cos(\\theta/2) \\end{pmatrix} = u3(\\theta, "
"-\\pi/2,\\pi/2)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:696
msgid "Rotation around Y-axis"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:698
msgid ""
"R_y(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) & - \\sin(\\theta/2)\\\\"
" \\sin(\\theta/2) & \\cos(\\theta/2). \\end{pmatrix} =u3(\\theta,0,0)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:736
msgid "Rotation around Z-axis"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:738
msgid ""
"R_z(\\phi) = \\begin{pmatrix} e^{-i \\phi/2} & 0 \\\\ 0 & e^{i \\phi/2} "
"\\end{pmatrix}\\equiv u1(\\phi)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:747
msgid ""
"Note here we have used an equivalent as is different to u1 by global "
"phase :math:`e^{-i \\phi/2}`."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:778
msgid "Note this is different due only to a global phase"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:781
msgid "Multi-Qubit Gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:784
msgid "Mathematical Preliminaries"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:786
msgid ""
"The space of quantum computer grows exponential with the number of "
"qubits. For :math:`n` qubits the complex vector space has dimensions "
":math:`d=2^n`. To describe states of a multi-qubit system, the tensor "
"product is used to “glue together” operators and basis vectors."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:791
msgid ""
"Let’s start by considering a 2-qubit system. Given two operators "
":math:`A` and :math:`B` that each act on one qubit, the joint operator "
":math:`A \\otimes B` acting on two qubits is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:795
msgid ""
"\\begin{equation}     A\\otimes B =     \\begin{pmatrix}         A_{00} "
"\\begin{pmatrix}             B_{00} & B_{01} \\\\             B_{10} & "
"B_{11}         \\end{pmatrix} & A_{01}  \\begin{pmatrix}                 "
"B_{00} & B_{01} \\\\                 B_{10} & B_{11}             "
"\\end{pmatrix} \\\\         A_{10}  \\begin{pmatrix}                     "
"B_{00} & B_{01} \\\\                     B_{10} & B_{11}                 "
"\\end{pmatrix} & A_{11}  \\begin{pmatrix}                             "
"B_{00} & B_{01} \\\\                             B_{10} & B_{11}"
"                         \\end{pmatrix}     \\end{pmatrix}, "
"\\end{equation}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:817
msgid ""
"where :math:`A_{jk}` and :math:`B_{lm}` are the matrix elements of "
":math:`A` and :math:`B`, respectively."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:820
msgid ""
"Analogously, the basis vectors for the 2-qubit system are formed using "
"the tensor product of basis vectors for a single qubit:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:823
msgid ""
"\\begin{equation}\\begin{split}     |{00}\\rangle &= \\begin{pmatrix}"
"         1 \\begin{pmatrix}             1  \\\\             0         "
"\\end{pmatrix} \\\\         0 \\begin{pmatrix}             1  \\\\"
"             0         \\end{pmatrix}     \\end{pmatrix} = "
"\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\0 \\end{pmatrix}~~~|{01}\\rangle = "
"\\begin{pmatrix}     1 \\begin{pmatrix}     0 \\\\     1     "
"\\end{pmatrix} \\\\     0 \\begin{pmatrix}     0  \\\\     1     "
"\\end{pmatrix}     \\end{pmatrix} = \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ "
"0 \\end{pmatrix}\\end{split} \\end{equation}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:847
msgid ""
"\\begin{equation}\\begin{split}|{10}\\rangle = \\begin{pmatrix}     "
"0\\begin{pmatrix}     1  \\\\     0     \\end{pmatrix} \\\\     "
"1\\begin{pmatrix}     1 \\\\     0     \\end{pmatrix}     \\end{pmatrix} "
"= \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix}~~~   "
"|{11}\\rangle = \\begin{pmatrix}     0 \\begin{pmatrix}     0  \\\\     1"
"     \\end{pmatrix} \\\\     1\\begin{pmatrix}     0  \\\\     1     "
"\\end{pmatrix}     \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 "
"\\\\1 \\end{pmatrix}\\end{split} \\end{equation}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:870
msgid ""
"Note we’ve introduced a shorthand for the tensor product of basis "
"vectors, wherein :math:`|0\\rangle \\otimes |0\\rangle` is written as "
":math:`|00\\rangle`. The state of an :math:`n`-qubit system can described"
" using the :math:`n`-fold tensor product of single-qubit basis vectors. "
"Notice that the basis vectors for a 2-qubit system are 4-dimensional; in "
"general, the basis vectors of an :math:`n`-qubit sytsem are "
":math:`2^{n}`-dimensional, as noted earlier."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:879
msgid "Basis vector ordering in Qiskit"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:881
msgid ""
"Within the physics community, the qubits of a multi-qubit systems are "
"typically ordered with the first qubit on the left-most side of the "
"tensor product and the last qubit on the right-most side. For instance, "
"if the first qubit is in state :math:`|0\\rangle` and second is in state "
":math:`|1\\rangle`, their joint state would be :math:`|01\\rangle`. "
"Qiskit uses a slightly different ordering of the qubits, in which the "
"qubits are represented from the most significant bit (MSB) on the left to"
" the least significant bit (LSB) on the right (big-endian). This is "
"similar to bitstring representation on classical computers, and enables "
"easy conversion from bitstrings to integers after measurements are "
"performed. For the example just given, the joint state would be "
"represented as :math:`|10\\rangle`. Importantly, *this change in the "
"representation of multi-qubit states affects the way multi-qubit gates "
"are represented in Qiskit*, as discussed below."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:896
msgid ""
"The representation used in Qiskit enumerates the basis vectors in "
"increasing order of the integers they represent. For instance, the basis "
"vectors for a 2-qubit system would be ordered as :math:`|00\\rangle`, "
":math:`|01\\rangle`, :math:`|10\\rangle`, and :math:`|11\\rangle`. "
"Thinking of the basis vectors as bit strings, they encode the integers "
"0,1,2 and 3, respectively."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:904
msgid "Controlled operations on qubits"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:906
msgid ""
"A common multi-qubit gate involves the application of a gate to one "
"qubit, conditioned on the state of another qubit. For instance, we might "
"want to flip the state of the second qubit when the first qubit is in "
":math:`|0\\rangle`. Such gates are known as *controlled gates*. The "
"standard multi-qubit gates consist of two-qubit gates and three-qubit "
"gates. The two-qubit gates are: - controlled Pauli gates - controlled "
"Hadamard gate - controlled rotation gates - controlled phase gate - "
"controlled u3 gate - swap gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:915
msgid "The three-qubit gates are: - Toffoli gate - Fredkin gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:918
msgid "Two-qubit gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:920
msgid ""
"Most of the two-gates are of the controlled type (the SWAP gate being the"
" exception). In general, a controlled two-qubit gate :math:`C_{U}` acts "
"to apply the single-qubit unitary :math:`U` to the second qubit when the "
"state of the first qubit is in :math:`|1\\rangle`. Suppose :math:`U` has "
"a matrix representation"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:926
msgid "U = \\begin{pmatrix} u_{00} & u_{01} \\\\ u_{10} & u_{11}\\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:928
msgid ""
"We can work out the action of :math:`C_{U}` as follows. Recall that the "
"basis vectors for a two-qubit system are ordered as :math:`|00\\rangle, "
"|01\\rangle, |10\\rangle, |11\\rangle`. Suppose the **control qubit** is "
"**qubit 0** (which, according to Qiskit’s convention, is one the *right-"
"hand* side of the tensor product). If the control qubit is in "
":math:`|1\\rangle`, :math:`U` should be applied to the **target** (qubit "
"1, on the *left-hand* side of the tensor product). Therefore, under the "
"action of :math:`C_{U}`, the basis vectors are transformed according to"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:938
msgid ""
"\\begin{align*} C_{U}: \\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{U|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{U|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle}\\\\ \\end{align*}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:947
msgid "In matrix form, the action of :math:`C_{U}` is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:949
msgid ""
"\\begin{equation}     C_U = \\begin{pmatrix}     1 & 0 & 0 & 0 \\\\     0"
" & u_{00} & 0 & u_{01} \\\\     0 & 0 & 1 & 0 \\\\     0 & u_{10} &0 & "
"u_{11}         \\end{pmatrix}. \\end{equation}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:960
msgid "To work out these matrix elements, let"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:962
msgid ""
"C_{(jk), (lm)} = \\left(\\underset{\\text{qubit}~1}{\\langle j |} "
"\\otimes \\underset{\\text{qubit}~0}{\\langle k |}\\right) C_{U} "
"\\left(\\underset{\\text{qubit}~1}{| l \\rangle} \\otimes "
"\\underset{\\text{qubit}~0}{| k \\rangle}\\right),"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:964
msgid ""
"compute the action of :math:`C_{U}` (given above), and compute the inner "
"products."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:967
msgid ""
"As shown in the examples below, this operation is implemented in Qiskit "
"as ``cU(q[0],q[1])``."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:970
msgid ""
"If **qubit 1 is the control and qubit 0 is the target**, then the basis "
"vectors are transformed according to"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:973
msgid ""
"\\begin{align*} C_{U}: \\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|0\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|0\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{U|0\\rangle}\\\\ C_{U}: "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{|1\\rangle} &\\rightarrow "
"\\underset{\\text{qubit}~1}{|1\\rangle}\\otimes "
"\\underset{\\text{qubit}~0}{U|1\\rangle}\\\\ \\end{align*},"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:982
msgid "which implies the matrix form of :math:`C_{U}` is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:984
msgid ""
"\\begin{equation}     C_U = \\begin{pmatrix}     1 & 0 & 0  & 0 \\\\     "
"0 & 1 & 0 & 0 \\\\     0 & 0 & u_{00} & u_{01} \\\\     0 & 0 & u_{10} & "
"u_{11}         \\end{pmatrix}. \\end{equation}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1000
msgid "Controlled Pauli Gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1003
msgid "Controlled-X (or, controlled-NOT) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1005
msgid ""
"The controlled-not gate flips the ``target`` qubit when the control qubit"
" is in the state :math:`|1\\rangle`. If we take the MSB as the control "
"qubit (e.g. ``cx(q[1],q[0])``), then the matrix would look like"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1009
msgid ""
"C_X = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & "
"1\\\\ 0 & 0 & 1 & 0 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1020
msgid ""
"However, when the LSB is the control qubit, (e.g. ``cx(q[0],q[1])``), "
"this gate is equivalent to the following matrix:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1023
msgid ""
"C_X = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 1\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & 1 & 0 & 0 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1065
msgid "Controlled :math:`Y` gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1067
msgid ""
"Apply the :math:`Y` gate to the target qubit if the control qubit is the "
"MSB"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1070
msgid ""
"C_Y = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & "
"-i\\\\ 0 & 0 & i & 0 \\end{pmatrix},"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1081
msgid "or when the LSB is the control"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1083
msgid ""
"C_Y = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & -i\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & i & 0 & 0 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1125
msgid "Controlled :math:`Z` (or, controlled Phase) gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1127
msgid ""
"Similarly, the controlled Z gate flips the phase of the target qubit if "
"the control qubit is :math:`1`. The matrix looks the same regardless of "
"whether the MSB or LSB is the control qubit:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1131
msgid ""
"C_Z = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & "
"0\\\\ 0 & 0 & 0 & -1 \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1173
msgid "Controlled Hadamard gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1175
msgid ""
"Apply :math:`H` gate to the target qubit if the control qubit is "
":math:`|1\\rangle`. Below is the case where the control is the LSB qubit."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1178
msgid ""
"C_H = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & \\frac{1}{\\sqrt{2}} & 0 & "
"\\frac{1}{\\sqrt{2}}\\\\ 0 & 0 & 1 & 0\\\\ 0 & \\frac{1}{\\sqrt{2}}  & 0&"
" -\\frac{1}{\\sqrt{2}} \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1220
msgid "Controlled rotation gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1223
msgid "Controlled rotation around Z-axis"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1225
msgid ""
"Perform rotation around Z-axis on the target qubit if the control qubit "
"(here LSB) is :math:`|1\\rangle`."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1228
msgid ""
"C_{Rz}(\\lambda) = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & "
"e^{-i\\lambda/2} & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & "
"e^{i\\lambda/2} \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1270
msgid "Controlled phase rotation"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1272
msgid ""
"Perform a phase rotation if both qubits are in the :math:`|11\\rangle` "
"state. The matrix looks the same regardless of whether the MSB or LSB is "
"the control qubit."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1276
msgid ""
"C_{u1}(\\lambda) = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0"
" & 0 & 1 & 0\\\\ 0 & 0 & 0 & e^{i\\lambda} \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1317
msgid "Controlled :math:`u3` rotation"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1319
msgid ""
"Perform controlled-\\ :math:`u3` rotation on the target qubit if the "
"control qubit (here LSB) is :math:`|1\\rangle`."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1322
msgid ""
"C_{u3}(\\theta, \\phi, \\lambda) \\equiv \\begin{pmatrix} 1 & 0 & 0 & "
"0\\\\ 0 & e^{-i(\\phi+\\lambda)/2}\\cos(\\theta/2) & 0 & "
"-e^{-i(\\phi-\\lambda)/2}\\sin(\\theta/2)\\\\ 0 & 0 & 1 & 0\\\\ 0 & "
"e^{i(\\phi-\\lambda)/2}\\sin(\\theta/2) & 0 & "
"e^{i(\\phi+\\lambda)/2}\\cos(\\theta/2) \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1363
msgid "SWAP gate"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1365
msgid "The SWAP gate exchanges the two qubits. It transforms the basis vectors as"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1368
msgid ""
"|00\\rangle \\rightarrow |00\\rangle~,~|01\\rangle \\rightarrow "
"|10\\rangle~,~|10\\rangle \\rightarrow |01\\rangle~,~|11\\rangle "
"\\rightarrow |11\\rangle,"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1370
msgid "which gives a matrix representation of the form"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1372
msgid ""
"\\mathrm{SWAP} = \\begin{pmatrix} 1 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 &"
" 1 & 0 & 0\\\\ 0 & 0 & 0 & 1 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1413
msgid "Three-qubit gates"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1415
msgid ""
"There are two commonly-used three-qubit gates. For three qubits, the "
"basis vectors are ordered as"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1418
msgid ""
"|000\\rangle, |001\\rangle, |010\\rangle, |011\\rangle, |100\\rangle, "
"|101\\rangle, |110\\rangle, |111\\rangle,"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1420
msgid ""
"which, as bitstrings, represent the integers :math:`0,1,2,\\cdots, 7`. "
"Again, Qiskit uses a representation in which the first qubit is on the "
"right-most side of the tensor product and the third qubit is on the left-"
"most side:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1425
msgid ""
"|abc\\rangle : \\underset{\\text{qubit 2}}{|a\\rangle}\\otimes "
"\\underset{\\text{qubit 1}}{|b\\rangle}\\otimes \\underset{\\text{qubit "
"0}}{|c\\rangle}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1428
msgid "Toffoli gate (:math:`ccx` gate)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1430
msgid ""
"The `Toffoli gate "
"<https://en.wikipedia.org/wiki/Quantum_logic_gate#Toffoli_(CCNOT)_gate>`__"
" flips the third qubit if the first two qubits (LSB) are both "
":math:`|1\\rangle`:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1435
msgid ""
"|abc\\rangle \\rightarrow |bc\\oplus a\\rangle \\otimes |b\\rangle "
"\\otimes c \\rangle."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1437
msgid "In matrix form, the Toffoli gate is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1439
msgid ""
"C_{CX} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0"
" & 0 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 "
"& 0 & 0 & 1\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 1 &"
" 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & "
"0 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1492
msgid "Controlled swap gate (Fredkin Gate)"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1494
msgid ""
"The `Fredkin gate "
"<https://en.wikipedia.org/wiki/Quantum_logic_gate#Fredkin_(CSWAP)_gate>`__,"
" or the *controlled swap gate*, exchanges the second and third qubits if "
"the first qubit (LSB) is :math:`|1\\rangle`:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1499
msgid ""
"|abc\\rangle \\rightarrow \\begin{cases} |bac\\rangle~~\\text{if}~c=1 "
"\\cr |abc\\rangle~~\\text{if}~c=0 \\end{cases}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1501
msgid "In matrix form, the Fredkin gate is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1503
msgid ""
"C_{\\mathrm{SWAP}} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0"
" & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\ 0 & 0 "
"& 0 & 0 & 0 & 1 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\ 0 & 0 & 0 &"
" 1 & 0 & 0 & 0 & 0\\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 0 & "
"0 & 0 & 0 & 1 \\end{pmatrix}."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1552
msgid "Non unitary operations"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1554
msgid ""
"Now we have gone through all the unitary operations in quantum circuits "
"we also have access to non-unitary operations. These include "
"measurements, reset of qubits, and classical conditional operations."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1564
msgid "Measurements"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1566
msgid ""
"We don’t have access to all the information when we make a measurement in"
" a quantum computer. The quantum state is projected onto the standard "
"basis. Below are two examples showing a circuit that is prepared in a "
"basis state and the quantum computer prepared in a superposition state."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1599
msgid ""
"The simulator predicts that 100 percent of the time the classical "
"register returns 0."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1631
msgid ""
"The simulator predicts that 50 percent of the time the classical register"
" returns 0 or 1."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1635
msgid "Reset"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1637
msgid ""
"It is also possible to ``reset`` qubits to the :math:`|0\\rangle` state "
"in the middle of computation. Note that ``reset`` is not a Gate "
"operation, since it is irreversible."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1696
msgid ""
"Here we see that for both of these circuits the simulator always predicts"
" that the output is 100 percent in the 0 state."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1700
msgid "Conditional operations"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1702
msgid ""
"It is also possible to do operations conditioned on the state of the "
"classical register"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1720
msgid ""
"Here the classical bit always takes the value 0 so the qubit state is "
"always flipped."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1767
msgid ""
"Here the classical bit by the first measurement is random but the "
"conditional operation results in the qubit being deterministically put "
"into :math:`|1\\rangle`."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1772
msgid "Arbitrary initialization"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1774
msgid ""
"What if we want to initialize a qubit register to an arbitrary state? An "
"arbitrary state for :math:`n` qubits may be specified by a vector of "
":math:`2^n` amplitudes, where the sum of amplitude-norms-squared equals "
"1. For example, the following three-qubit state can be prepared:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1779
msgid ""
"|\\psi\\rangle = \\frac{i}{4}|000\\rangle + "
"\\frac{1}{\\sqrt{8}}|001\\rangle + \\frac{1+i}{4}|010\\rangle + "
"\\frac{1+2i}{\\sqrt{8}}|101\\rangle + \\frac{1}{4}|110\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1830
msgid ""
"`Fidelity <https://en.wikipedia.org/wiki/Fidelity_of_quantum_states>`__ "
"is useful to check whether two states are same or not. For quantum (pure)"
" states :math:`\\left|\\psi_1\\right\\rangle` and "
":math:`\\left|\\psi_2\\right\\rangle`, the fidelity is"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1835
msgid ""
"F\\left(\\left|\\psi_1\\right\\rangle,\\left|\\psi_2\\right\\rangle\\right)"
" = \\left|\\left\\langle\\psi_1\\middle|\\psi_2\\right\\rangle\\right|^2."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1840
msgid "The fidelity is equal to :math:`1` if and only if two states are same."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1856
msgid "Further details:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1858
msgid ""
"How does the desired state get generated behind the scenes? There are "
"multiple methods for doing this. Qiskit uses a `method proposed by Shende"
" et al <https://arxiv.org/abs/quant-ph/0406176>`__. Here, the idea is to "
"assume the quantum register to have started from our desired state, and "
"construct a circuit that takes it to the :math:`|00..0\\rangle` state. "
"The initialization circuit is then the reverse of such circuit."
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1866
msgid ""
"To take an arbitrary quantum state to the zero state in the computational"
" basis, we perform an iterative procedure that disentangles qubits from "
"the register one-by-one. We know that any arbitrary single-qubit state "
":math:`|\\rho\\rangle` can be taken to the :math:`|0\\rangle` state using"
" a :math:`\\phi`-degree rotation about the Z axis followed by a "
":math:`\\theta`-degree rotation about the Y axis:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1873
msgid "R_y(-\\theta)R_z(-\\phi)|\\rho\\rangle = re^{it}|0\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1875
msgid ""
"Since now we are dealing with :math:`n` qubits instead of just 1, we must"
" factorize the state vector to separate the Least Significant Bit (LSB):"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1879
msgid ""
"\\begin{align*}  |\\psi\\rangle =& \\alpha_{0_0}|00..00\\rangle + "
"\\alpha_{0_1}|00..01\\rangle + \\alpha_{1_0}|00..10\\rangle + "
"\\alpha_{1_1}|00..11\\rangle + ... \\\\&+ "
"\\alpha_{(2^{n-1}-1)_0}|11..10\\rangle + "
"\\alpha_{(2^{n-1}-1)_1}|11..11\\rangle \\\\ =& |00..0\\rangle "
"(\\alpha_{0_0}|0\\rangle + \\alpha_{0_1}|1\\rangle) + |00..1\\rangle "
"(\\alpha_{1_0}|0\\rangle + \\alpha_{1_1}|1\\rangle) + ... \\\\&+ "
"|11..1\\rangle (\\alpha_{(2^{n-1}-1)_0}(|0\\rangle + "
"\\alpha_{(2^{n-1}-1)_1}|1\\rangle) \\\\ =& |00..0\\rangle|\\rho_0\\rangle"
" + |00..1\\rangle|\\rho_1\\rangle + ... + "
"|11..1\\rangle|\\rho_{2^{n-1}-1}\\rangle \\end{align*}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1887
msgid ""
"Now each of the single-qubit states :math:`|\\rho_0\\rangle, ..., "
"|\\rho_{2^{n-1}-1}\\rangle` can be taken to :math:`|0\\rangle` by finding"
" appropriate :math:`\\phi` and :math:`\\theta` angles per the equation "
"above. Doing this simultaneously on all states amounts to the following "
"unitary, which disentangles the LSB:"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1893
msgid ""
"U = \\begin{pmatrix} R_{y}(-\\theta_0)R_{z}(-\\phi_0) & & & &\\\\ & "
"R_{y}(-\\theta_1)R_{z}(-\\phi_1) & & &\\\\ & . & & &\\\\ & & . & &\\\\ & "
"& & & R_y(-\\theta_{2^{n-1}-1})R_z(-\\phi_{2^{n-1}-1}) \\end{pmatrix}"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1903
msgid "Hence,"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1905
msgid ""
"U|\\psi\\rangle = \\begin{pmatrix} r_0e^{it_0}\\\\ r_1e^{it_1}\\\\ . \\\\"
" . \\\\ r_{2^{n-1}-1}e^{it_{2^{n-1}-1}} \\end{pmatrix}\\otimes|0\\rangle"
msgstr ""

#: ../../../terra/summary_of_quantum_operations.rst:1907
msgid ""
"U can be implemented as a “quantum multiplexor” gate, since it is a block"
" diagonal matrix. In the quantum multiplexor formalism, a block diagonal "
"matrix of size :math:`2^n \\times 2^n`, and consisting of :math:`2^s` "
"blocks, is equivalent to a multiplexor with :math:`s` select qubits and "
":math:`n-s` data qubits. Depending on the state of the select qubits, the"
" corresponding blocks are applied to the data qubits. A multiplexor of "
"this kind can be implemented after recursive decomposition to primitive "
"gates of cx, rz and ry."
msgstr ""

