# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-05 16:34+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../../terra/executing_quantum_programs.rst:5
msgid "Executing Quantum Programs"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:7
msgid "The general workflow for executing a quantum program is as follows:"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:9
msgid "Build your circuit"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:10
msgid "Choose your **backend**"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:11
msgid "Execute your circuit on your backend, returning a **job** object"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:12
msgid "Access the **result** from the job object via ``job.result()``"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:14
msgid ""
"A **backend** represents either a simulator or a real quantum computer, "
"responsible for running quantum circuits and returning results."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:17
msgid ""
"**Job** instances can be thought of as the “ticket” for a submitted job. "
"They find out the execution’s state at a given point in time (for "
"example, if the job is queued, running, or has failed) and also allow "
"control over the execution."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:22
msgid ""
"Once a job has finished, Qiskit Terra allows the **results** to be "
"obtained from the remote backends using ``result = job.result()``. This "
"result object holds the quantum data and the most common way of "
"interacting with it is by using ``result.get_counts(circuit)``. This "
"method gets the raw counts from the quantum circuit to use them for more "
"analysis with quantum information tools provided by Terra."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:29
msgid ""
"Each of the common backends are demonstrated in the subsequent sections "
"using the quantum circuit built as follows:"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:62
msgid "Simulating Circuits with Qiskit Aer"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:66
msgid "Statevector Simulator"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:68
msgid ""
"The most common backend in Qiskit Aer is the ``statevector_simulator``. "
"This simulator returns the quantum state which is a complex vector of "
"dimensions :math:`2^n` where :math:`n` is the number of qubits (so be "
"careful using this as it will quickly get too large to run on your "
"machine)."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:75
msgid ""
"When representing the state of a multi-qubit system, the tensor order "
"used in Qiskit is different than that use in most physics textbooks. "
"Suppose there are :math:`n` qubits, and qubit :math:`j` is labeled as "
":math:`Q_j`. In most textbooks (such as Nielsen and Chuang’s “Quantum "
"Computation and Information”), the basis vectors for the :math:`n`-qubit "
"state space would be labeled as :math:`Q_0 ⊗ Q_1 ⊗⋯⊗ Q_n`. **This is not "
"the ordering used by Qiskit!** Instead, Qiskit uses an ordering in which "
"the :math:`n^{th}` qubit is on the left side of the tesnsor product, so "
"that the basis vectors are labeled as :math:`Q_n ⊗⋯⊗ Q_1 ⊗ Q_0`. For "
"example, if qubit zero is in state 0, qubit 1 is in state 0, and qubit 2 "
"is in state 1, Qiskit would represent this state as :math:`|100\\rangle`,"
" whereas most physics textbooks would represent it as "
":math:`|001\\rangle`. This difference in labeling affects the way multi-"
"qubit operations are represented as matrices. For example, Qiskit "
"represents a controlled-X (:math:`C_X`) operation with qubit 0 being the "
"control and qubit 1 being the target as"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:91
msgid ""
"C_X = \\begin{bmatrix}  1 & 0 & 0 & 0 \\\\  0 & 0 & 0 & 1 \\\\  0 & 0 & 1"
" & 0 \\\\  0 & 1 & 0 & 0  \\end{bmatrix}"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:99
msgid ""
"To run the above circuit using the statevector simulator, first you need "
"to import Aer and then set the backend to ``statevector_simulator``."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:110
msgid ""
"Now we have chosen the backend it’s time to compile and run the quantum "
"circuit. In Qiskit we provide the ``execute`` function for this. "
"``execute`` returns a ``job`` object that encapsulates information about "
"the job submitted to the backend."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:120
msgid ""
"When you run a program, a job object is made that has the following two "
"useful methods: ``job.status()`` and ``job.result()`` which return the "
"status of the job and a result object respectively."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:126
msgid ""
"Jobs run asynchronously but when the result method is called it switches "
"to synchronous and waits for it to finish before moving on to another "
"task."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:133
msgid ""
"The results object contains the data and Qiskit provides the method "
"``result.get_statevector(circ)`` to return the state vector for the "
"quantum circuit."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:148
msgid ""
"Qiskit also provides a visualization toolbox to allow you to view these "
"results."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:150
msgid ""
"Below, we use the visualization function to plot the real and imaginary "
"components of the state vector."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:168
msgid "Unitary Simulator"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:170
msgid ""
"Qiskit Aer also includes a ``unitary_simulator`` that works provided all "
"the elements in the circuit are unitary operations. This backend "
"calculates the :math:`2^n × 2^n` matrix representing the gates in the "
"quantum circuit."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:196
msgid "OpenQASM Simulator"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:198
msgid ""
"The simulators above are useful because they provide information about "
"the state output by the ideal circuit and the matrix representation of "
"the circuit. However, a real experiment terminates by measuring each "
"qubit (usually in the computational :math:`|0\\rangle`, "
":math:`|1\\rangle` basis). Without measurement, we cannot gain "
"information about the state. Measurements cause the quantum system to "
"collapse into classical bits."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:205
msgid ""
"For example, suppose we make independent measurements on each qubit of "
"the two-qubit Bell state"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:208
msgid "|\\psi\\rangle = \\left(|00\\rangle+|11\\rangle\\right)/\\sqrt{2}."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:210
msgid ""
"and let :math:`x_1x_0` denote the bitstring that results. Recall that, "
"under the qubit labeling used by Qiskit, :math:`x_1` would correspond to "
"the outcome on qubit 1 and :math:`x_0` to the outcome on qubit 0."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:216
msgid ""
"This representation of the bitstring puts the most significant bit (MSB) "
"on the left, and the least significant bit (LSB) on the right. This is "
"the standard ordering of binary bitstrings. We order the qubits in the "
"same way, which is why Qiskit uses a non-standard tensor product order."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:221
msgid "The probability of obtaining outcome :math:`x_1x_0` is given by"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:223
msgid "Pr(x_1x_0) = |\\langle{x_1x_0|\\psi}\\rangle|^2"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:225
msgid ""
"By explicit computation, we see there are only two bitstrings that will "
"occur: :math:`00` and :math:`11`. If the bitstring :math:`00` is "
"obtained, the state of the qubits is :math:`|00\\rangle`, and if the "
"bitstring is :math:`11`, the qubits are left in the state "
":math:`|11\\rangle`. The probability of obtaining :math:`00` or "
":math:`11` is the same; namely, 1/2:"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:231
msgid "Pr(00) = |\\langle00|\\psi\\rangle|^2 = \\frac{1}{2}"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:233
msgid "Pr(11) = |\\langle11|\\psi\\rangle|^2 = \\frac{1}{2}"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:235
msgid ""
"To simulate a circuit that includes measurement, we need to add "
"measurements to the original circuit above, and use a different Aer "
"backend."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:263
msgid ""
"This circuit adds a classical register, and two measurements that are "
"used to map the outcome of qubits to the classical bits."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:266
msgid ""
"To simulate this circuit, we use the ``qasm_simulator`` in Qiskit Aer. "
"Each run of this circuit will yield either the bitstring :math:`00` or "
":math:`11`. To build up statistics about the distribution of the "
"bitstrings (to, e.g., estimate :math:`Pr(00)`), we need to repeat the "
"circuit many times. The number of times the circuit is repeated can be "
"specified in the ``execute`` function, via the ``shots`` keyword."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:286
msgid ""
"Once you have a result object, you can access the counts via the function"
" ``get_counts(circuit)``. This gives you the aggregated binary outcomes "
"of the circuit you submitted."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:301
msgid ""
"Approximately 50 percent of the time the output bitstring is :math:`00`. "
"Qiskit also provides a function ``plot_histogram`` which allows you to "
"view the outcomes."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:320
msgid "Running Circuits on IBM Q Devices"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:322
msgid ""
"To facilitate access to real quantum computing hardware, we have provided"
" a simple API interface. To follow along with this section, first be sure"
" to set up an IBM Q account as explained in the "
":ref:`install_access_ibm_q_devices_label` section of the Qiskit "
"installation instructions."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:327
msgid "Load your IBM Q account credentials by calling"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:334
msgid ""
"Once your account has been loaded, you can view the list of devices "
"available to you."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:357
msgid "Running Circuits on Real Devices"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:359
msgid ""
"Today’s quantum information processors are small and noisy, but are "
"advancing at a fast pace. They provide a great opportunity to explore "
"what noisy quantum computers can do."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:363
msgid ""
"The IBM Q provider uses a queue to allocate the devices to users. We now "
"choose a device with the least busy queue which can support our program "
"(has at least 3 qubits)."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:381
msgid ""
"To run the circuit on the backend, we need to specify the number of shots"
" and the number of credits we are willing to spend to run the circuit. "
"Then, we execute the circuit on the backend using the ``execute`` "
"function."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:403
msgid ""
"``job_exp`` has a ``.result()`` method that lets us get the results from "
"running our circuit."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:408
msgid ""
"When the ``.result()`` method is called, the code block will wait until "
"the job has finished before releasing the cell."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:415
msgid ""
"Like before, the counts from the execution can be obtained using "
"``get_counts(qc)``"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:433
msgid "Simulating Circuits on HPC"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:435
msgid ""
"The IBM Q provider also comes with a remote optimized simulator called "
"``ibmq_qasm_simulator``. This remote simulator is capable of simulating "
"up to 32 qubits. It can be used the same way as the remote real backends."
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:473
msgid "Retrieving a Previously Run Job"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:475
msgid ""
"If your experiment takes longer to run then you have time to wait around,"
" or if you simply want to retrieve old jobs back, the IBM Q backends "
"allow you to do that. First you would need to note your job’s ID:"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:491
msgid ""
"Given a job ID, that job object can be later reconstructed from the "
"backend using ``retrieve_job``:"
msgstr ""

#: ../../../terra/executing_quantum_programs.rst:498
msgid "and then the results can be obtained from the new job object."
msgstr ""

