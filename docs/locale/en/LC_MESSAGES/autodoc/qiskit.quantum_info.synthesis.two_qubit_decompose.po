# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-12 14:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../autodoc/qiskit.quantum_info.synthesis.two_qubit_decompose.rst:2
msgid "qiskit.quantum\\_info.synthesis.two\\_qubit\\_decompose module"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose:1
msgid ""
"Expand 2-qubit Unitary operators into an equivalent decomposition over "
"SU(2)+fixed 2q basis gate, using the KAK method."
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose:4
msgid ""
"May be exact or approximate expansion. In either case uses the minimal "
"number of basis applications."
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose:7
msgid ""
"Method is described in Appendix B of Cross, A. W., Bishop, L. S., "
"Sheldon, S., Nation, P. D. & Gambetta, J. M. Validating quantum computers"
" using randomized model circuits. arXiv:1811.12926 [quant-ph] (2018)."
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer:1
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitWeylDecomposition:1
msgid "„Éô„Éº„Çπ„ÇØ„É©„Çπ: :class:`object`"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer:1
msgid ""
"A class for decomposing 2-qubit unitaries into minimal number of uses of "
"a 2-qubit basis gate."
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp0:1
msgid ""
"Decompose target ~Ud(x, y, z) with 0 uses of the basis gate. Result Ur "
"has trace: |Tr(Ur.Utarget^dag)| = 4|(cos(x)cos(y)cos(z)+ j "
"sin(x)sin(y)sin(z)|, which is optimal for all targets and bases"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp1:1
msgid ""
"Decompose target ~Ud(x, y, z) with 1 uses of the basis gate ~Ud(a, b, c)."
" Result Ur has trace: |Tr(Ur.Utarget^dag)| = 4|cos(x-a)cos(y-b)cos(z-c) +"
" j sin(x-a)sin(y-b)sin(z-c)|, which is optimal for all targets and bases "
"with z==0 or c==0"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp2_supercontrolled:1
msgid ""
"Decompose target ~Ud(x, y, z) with 2 uses of the basis gate. For "
"supercontrolled basis ~Ud(pi/4, b, 0), all b, result Ur has trace: "
"|Tr(Ur.Utarget^dag)| = 4cos(z) which is the optimal approximation for "
"basis of CNOT-class ~Ud(pi/4, 0, 0) or DCNOT-class ~Ud(pi/4, pi/4, 0) and"
" any target. May be sub-optimal for b!=0 (eg there exists exact "
"decomposition for any target using B"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp2_supercontrolled:7
msgid "B~Ud(pi/4, pi/8, 0), but not this decomposition.)"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp2_supercontrolled:8
msgid ""
"This is an exact decomposition for supercontrolled basis and target "
"~Ud(x, y, 0). No guarantees for non-supercontrolled basis."
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.decomp3_supercontrolled:1
msgid ""
"Decompose target with 3 uses of the basis. This is an exact decomposition"
" for supercontrolled basis ~Ud(pi/4, b, 0), all b, and any target. No "
"guarantees for non-supercontrolled basis."
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitBasisDecomposer.traces:1
msgid ""
"Give the expected traces |Tr(U.Utarget^dag)| for different number of "
"basis gates"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.TwoQubitWeylDecomposition:1
msgid ""
"Decompose two-qubit unitary U = (K1l‚äóK1r).Exp(i a xx + i b yy + i c "
"zz).(K2l‚äóK2r) , where U ‚àà U(4), (K1l|K1r|K2l|K2r) ‚àà SU(2), and we stay in"
" the \"Weyl Chamber\" ùúã/4 ‚â• a ‚â• b ‚â• |c|"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.Ud:1
msgid "Generates the array Exp(i(a xx + b yy + c zz))"
msgstr ""

#: of
#: qiskit.quantum_info.synthesis.two_qubit_decompose.decompose_two_qubit_product_gate:1
msgid ""
"Decompose U = Ul‚äóUr where U in SU(4), and Ul, Ur in SU(2). Throws "
"QiskitError if this isn't possible."
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q:1
msgid "Compute Euler angles for a single-qubit gate."
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q:3
msgid ""
"Find angles (theta, phi, lambda) such that unitary_matrix = phase * "
"Rz(phi) * Ry(theta) * Rz(lambda)"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q
msgid "„Éë„É©„É°„Éº„Çø"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q:6
msgid "2x2 unitary matrix"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q
msgid "Êàª„ÇäÂÄ§"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q:9
msgid "(theta, phi, lambda) Euler angles of SU(2)"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q
msgid "Êàª„ÇäÂÄ§„ÅÆÂûã"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q
msgid "raises"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.euler_angles_1q:12
msgid ":exc:`QiskitError` -- if unitary_matrix not 2x2, or failure"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.rz_array:1
msgid "Return numpy array for Rz(theta)."
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.rz_array:3
msgid "Rz(theta) = diag(exp(-i*theta/2),exp(i*theta/2))"
msgstr ""

#: of qiskit.quantum_info.synthesis.two_qubit_decompose.trace_to_fid:1
msgid ""
"Average gate fidelity is Fbar = (d + |Tr (Utarget.U^dag)|^2) / d(d+1) M. "
"Horodecki, P. Horodecki and R. Horodecki, PRA 60, 1888 (1999)"
msgstr ""

