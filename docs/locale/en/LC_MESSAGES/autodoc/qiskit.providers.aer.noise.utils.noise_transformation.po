# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-12 14:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../autodoc/qiskit.providers.aer.noise.utils.noise_transformation.rst:2
msgid "qiskit.providers.aer.noise.utils.noise\\_transformation module"
msgstr ""

#: of qiskit.providers.aer.noise.utils.noise_transformation:1
msgid "Noise transformation module"
msgstr ""

#: of qiskit.providers.aer.noise.utils.noise_transformation:3
msgid ""
"The goal of this module is to transform one 1-qubit noise channel (given "
"by the QuantumError class) into another, built from specified \"building "
"blocks\" (given as Kraus matrices) such that the new channel is as close "
"as possible to the original one in the Hilber-Schmidt metric."
msgstr ""

#: of qiskit.providers.aer.noise.utils.noise_transformation:8
msgid ""
"For a typical use case, consider a simulator for circuits built from the "
"Clifford group. Computations on such circuits can be simulated at "
"polynomial time and space, but not all noise channels can be used in such"
" a simulation. To enable noisy Clifford simulation one can transform the "
"given noise channel into the closest one, Hilbert-Schmidt wise, that can "
"be used in a Clifford simulator."
msgstr ""

#: of qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer:1
msgid "ベースクラス: :class:`object`"
msgstr ""

#: of qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer:1
msgid "Transforms one quantum channel to another based on a specified criteria."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices:1
msgid ""
"Generates a list of 4x4 symbolic matrices describing the channel defined "
"from the given operators"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_quadratic_programming_matrices
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error
msgid "パラメータ"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices:3
msgid "a list of tuples of matrices which represent Kraus operators"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices:14
msgid ""
"We consider this input to symbolically represent a channel in the "
"following manner: define indeterminates x0, x1, ..., xn which are meant "
"to represent probabilities such that xi >=0 and x0 = 1-(x1 + ... + xn) "
"Now consider the quantum channel defined via the Kraus operators "
"{sqrt(x0)I, sqrt(x1)A1, sqrt(x1)B1, ..., sqrt(xn)An, sqrt(xn)Bn, ...} "
"This is the channel C symbolically represented by the operators"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices:24
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_quadratic_programming_matrices:5
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_circuit:6
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:24
msgid "Output:"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_matrices:23
msgid ""
"A list of 4x4 complex matrices ([D1, D2, ..., Dn], E) such that: The "
"matrix x1*D1 + ... + xn*Dn + E represents the operation of the channel C "
"on the density operator we find it easier to work with this "
"representation of C when performing the combinatorial optimization"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_quadratic_programming_matrices:1
msgid "a 4x4 symbolic matrix"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_quadratic_programming_matrices:2
msgid "the symbols x1, ..., xn which may occur in the matrix"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.generate_channel_quadratic_programming_matrices:5
msgid ""
"A list of 4x4 complex matrices ([D1, D2, ..., Dn], E) such that: channel "
"== x1*D1 + ... + xn*Dn + E"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:1
msgid "Extract the numeric constant matrix."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:3
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:3
msgid "a 4x4 symbolic matrix."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:5
msgid "The full list [x1, ..., xn] of symbols used in the matrix."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:10
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:9
msgid "Returns"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:10
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:9
msgid "matrix: a 4x4 numeric matrix."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_const_matrix_from_channel:14
msgid ""
"Each entry of the 4x4 symbolic input channel matrix is assumed to be a "
"polynomial of the form a1x1 + ... + anxn + c. The corresponding entry in "
"the output numeric matrix is c."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:1
msgid "Extract the numeric parameter matrix."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:5
msgid "a symbol xi"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.get_matrix_from_channel:13
msgid ""
"Each entry of the 4x4 symbolic input channel matrix is assumed to be a "
"polynomial of the form a1x1 + ... + anxn + c. The corresponding entry in "
"the output numeric matrix is ai."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_circuit:1
msgid ""
"Converts an operator representation to noise circuit :param operator: "
"operator representation. Can be a noise"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_circuit:3
msgid "circuit or a matrix or a list of matrices."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_circuit:7
msgid "List: The operator, converted to noise circuit representation."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix:1
msgid "Converts an operator representation to Kraus matrix representation"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix:3
msgid ""
"operator representation. Can be a noise circuit or a matrix or a list of "
"matrices."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error
msgid "戻り値"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix:7
msgid "the operator, converted to Kraus representation."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.operator_matrix
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error
msgid "戻り値の型"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:1
msgid "a list of matrices (Kraus operators) for the input channel"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:2
msgid "a list of matrices or tuples of matrices"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:9
msgid ""
"A list of amplitudes that define the output channel. In the case the "
"input is a list [A1, A2, ..., An] of transform matrices and [E0, E1, ...,"
" Em] of noise kraus operators, the output is a list [p1, p2, ..., pn] of "
"probabilities such that: 1) p_i >= 0 2) p1 + ... + pn <= 1 3) "
"[sqrt(p1)A1, sqrt(p2)A2, ..., sqrt(pn)An, sqrt(1-(p1 + ... + pn))I] is"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:16
msgid ""
"a list of kraus operators that define the output channel (which is "
"\"close\" to the input chanel given by [E0, ..., Em])"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:19
msgid ""
"This channel can be thought of as choosing the operator Ai in probability"
" pi and applying this operator to the quantum state."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.NoiseTransformer.transform_by_operator_list:22
msgid ""
"More generally, if the input is a list of tuples (not neccesarily of the "
"same size): [(A1, B1, ...), (A2, B2, ...), ... (An, Bn, ...)] then the "
"output is still a list [p1, p2, ..., pn] and now the output channel is "
"defined by the operators [sqrt(p1)A1, sqrt(p1)B1, ..., sqrt(pn)An, "
"sqrt(pn)Bn, ..., sqrt(1-(p1 + ... + pn))I]"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:1
msgid "Return an approximate noise model."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:3
msgid "the noise model to be approximated."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:5
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:7
msgid ""
"a name for a premade set of building blocks for the output channel "
"(Default: None)."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:8
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:10
msgid ""
"a dictionary whose values are the building blocks for the output channel "
"(Default: None)."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:11
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:13
msgid "list of building blocks for the output channel (Default: None)."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:15
msgid "the approximate noise model."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error
msgid "raises"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:18
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:20
msgid ":exc:`NoiseError` -- if number of qubits is not supported or approximation"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:19
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:21
msgid ":exc:`failsed.`"
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_noise_model:23
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:25
msgid ""
"The operator input precedence is as follows: list < dict < string if a "
"string is given, dict is overwritten; if a dict is given, list is "
"overwritten possible values for string are 'pauli', 'reset', 'clifford' "
"For further information see `NoiseTransformer.named_operators`."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:1
msgid "Return an approximate QuantumError bases on the Hilbert-Schmidt metric."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:3
msgid "Currently this is only implemented for 1-qubit QuantumErrors."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:5
msgid "the error to be approximated."
msgstr ""

#: of
#: qiskit.providers.aer.noise.utils.noise_transformation.approximate_quantum_error:17
msgid "the approximate quantum error."
msgstr ""

