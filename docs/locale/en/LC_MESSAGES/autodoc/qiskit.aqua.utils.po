# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, Qiskit Development Team
# This file is distributed under the same license as the Qiskit package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Qiskit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-12 14:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../autodoc/qiskit.aqua.utils.rst:2
msgid "qiskit.aqua.utils package"
msgstr ""

#: of qiskit.aqua.utils.tensorproduct:1
msgid "Calculate tensor product."
msgstr ""

#: of qiskit.aqua.utils.tensorproduct:3
msgid ""
"m = tensorproduct(a,b,c,...) returns the kronecker product of its "
"arguments. Each argument should either be a tensor, or a tuple containing"
" a tensor and an integer, and tensor is put in zero-index slot. In the "
"latter case, the integer specifies the repeat count for the tensor, e.g. "
"tensorproduct(a,(b,3),c) = tensorproduct(a,b,b,b,c)."
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit
#: qiskit.aqua.utils.CircuitFactory.build
#: qiskit.aqua.utils.CircuitFactory.build_controlled
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse
#: qiskit.aqua.utils.CircuitFactory.build_inverse
#: qiskit.aqua.utils.build_measurement_error_mitigation_fitter
#: qiskit.aqua.utils.compile_and_run_circuits
#: qiskit.aqua.utils.compile_circuits qiskit.aqua.utils.convert_dict_to_json
#: qiskit.aqua.utils.find_regs_by_name qiskit.aqua.utils.get_entangler_map
#: qiskit.aqua.utils.get_feature_dimension
#: qiskit.aqua.utils.get_measured_qubits_from_qobj
#: qiskit.aqua.utils.get_num_classes
#: qiskit.aqua.utils.get_subsystem_density_matrix
#: qiskit.aqua.utils.get_subsystems_counts
#: qiskit.aqua.utils.map_label_to_class_name
#: qiskit.aqua.utils.mitigate_measurement_error qiskit.aqua.utils.optimize_svm
#: qiskit.aqua.utils.random_h1_body qiskit.aqua.utils.random_hermitian
#: qiskit.aqua.utils.random_non_hermitian qiskit.aqua.utils.random_unitary
#: qiskit.aqua.utils.reduce_dim_to_via_pca qiskit.aqua.utils.run_qobjs
#: qiskit.aqua.utils.split_dataset_to_data_and_labels
#: qiskit.aqua.utils.summarize_circuits qiskit.aqua.utils.tensorproduct
#: qiskit.aqua.utils.validate_entangler_map
msgid "パラメータ"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter
#: qiskit.aqua.utils.compile_and_run_circuits
#: qiskit.aqua.utils.compile_circuits qiskit.aqua.utils.convert_dict_to_json
#: qiskit.aqua.utils.convert_json_to_dict qiskit.aqua.utils.find_regs_by_name
#: qiskit.aqua.utils.get_entangler_map qiskit.aqua.utils.get_feature_dimension
#: qiskit.aqua.utils.get_measured_qubits_from_qobj
#: qiskit.aqua.utils.get_num_classes
#: qiskit.aqua.utils.get_subsystem_density_matrix
#: qiskit.aqua.utils.get_subsystems_counts
#: qiskit.aqua.utils.map_label_to_class_name
#: qiskit.aqua.utils.mitigate_measurement_error qiskit.aqua.utils.optimize_svm
#: qiskit.aqua.utils.random_h1_body qiskit.aqua.utils.random_h2_body
#: qiskit.aqua.utils.random_hermitian qiskit.aqua.utils.random_non_hermitian
#: qiskit.aqua.utils.random_unitary qiskit.aqua.utils.reduce_dim_to_via_pca
#: qiskit.aqua.utils.run_qobjs
#: qiskit.aqua.utils.split_dataset_to_data_and_labels
#: qiskit.aqua.utils.tensorproduct qiskit.aqua.utils.validate_entangler_map
msgid "戻り値"
msgstr ""

#: of qiskit.aqua.utils.tensorproduct:11
msgid "the tensor product"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter
#: qiskit.aqua.utils.compile_and_run_circuits
#: qiskit.aqua.utils.compile_circuits qiskit.aqua.utils.convert_dict_to_json
#: qiskit.aqua.utils.convert_json_to_dict qiskit.aqua.utils.find_regs_by_name
#: qiskit.aqua.utils.get_feature_dimension
#: qiskit.aqua.utils.get_measured_qubits_from_qobj
#: qiskit.aqua.utils.get_num_classes qiskit.aqua.utils.map_label_to_class_name
#: qiskit.aqua.utils.mitigate_measurement_error qiskit.aqua.utils.optimize_svm
#: qiskit.aqua.utils.random_h1_body qiskit.aqua.utils.random_h2_body
#: qiskit.aqua.utils.random_hermitian qiskit.aqua.utils.random_non_hermitian
#: qiskit.aqua.utils.random_unitary qiskit.aqua.utils.reduce_dim_to_via_pca
#: qiskit.aqua.utils.run_qobjs
#: qiskit.aqua.utils.split_dataset_to_data_and_labels
#: qiskit.aqua.utils.tensorproduct
msgid "戻り値の型"
msgstr ""

#: of qiskit.aqua.utils.CircuitCache:1 qiskit.aqua.utils.PauliGraph:1
msgid "ベースクラス: :class:`object`"
msgstr ""

#: of qiskit.aqua.utils.PauliGraph:1
msgid "Pauli Graph."
msgstr ""

#: of qiskit.aqua.utils.PauliGraph.grouped_paulis:1
msgid "Getter of grouped Pauli list."
msgstr ""

#: of qiskit.aqua.utils.convert_dict_to_json:1
msgid ""
"Combs recursively through a list/dictionary and finds any non-json     "
"compatible elements and converts them. E.g. complex ndarray's are     "
"converted to lists of strings. Assume that all such elements are     "
"stored in dictionaries!"
msgstr ""

#: of qiskit.aqua.utils.convert_dict_to_json:3
msgid "the input dict/list"
msgstr ""

#: of qiskit.aqua.utils.convert_dict_to_json:6
#: qiskit.aqua.utils.convert_json_to_dict:5
msgid "Result in_item possibly modified"
msgstr ""

#: of qiskit.aqua.utils.convert_json_to_dict:1
msgid ""
"Combs recursively through a list/dictionary that was loaded from json"
"     and finds any lists that were converted from ndarray and converts "
"them back :param in_item: the input dict/list :type in_item: dict or list"
msgstr ""

#: of qiskit.aqua.utils.random_unitary:1
msgid "Generate a random unitary matrix with size NxN."
msgstr ""

#: of qiskit.aqua.utils.random_unitary:3
msgid "the dimension of unitary matrix"
msgstr ""

#: of qiskit.aqua.utils.random_h1_body:6 qiskit.aqua.utils.random_unitary:5
msgid "a 2-D matrix with np.complex data type."
msgstr ""

#: of qiskit.aqua.utils.random_h2_body:1
msgid ""
"Generate a random two body integrals. :param N: number of spin-orbitals "
"(dimentsion of h2) :type N: int :param M: number of non-zero entries "
":type M: int"
msgstr ""

#: of qiskit.aqua.utils.random_h2_body:7
msgid "a numpy 4-D tensor with np.complex data type."
msgstr ""

#: of qiskit.aqua.utils.random_h1_body:1
msgid "Generate a random one body integrals."
msgstr ""

#: of qiskit.aqua.utils.random_h1_body:3
msgid "the number of spin orbitals."
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:1
msgid ""
"Generate random hermitian (sparse) matix with given properties. Sparsity "
"is achieved by truncating Pauli matrices. Sparsity settings alternate the"
" eigenvalues due to truncation. :param N: size of matrix :type N: int "
":param eigs: list of N eigenvalues. Overrides K,"
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:7
msgid "eigrange"
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:9
msgid ""
"condition number. Either use only condition number K or list/tuple of (K,"
" lmin) or (K, lmin, sgn). Where lmin is the smallest eigenvalue and sign "
"+/- 1 specifies if eigenvalues can be negative."
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:15
msgid "[min, max] list for eigenvalue range. (default=[0, 1])"
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:18
msgid "limit for number of Pauli matrices."
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:20
#: qiskit.aqua.utils.random_non_hermitian:18
msgid "sparsity of matrix. Overrides trunc."
msgstr ""

#: of qiskit.aqua.utils.random_hermitian:23
msgid "hermitian matrix"
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:1
msgid ""
"Generate random (sparse) matrix with given properties (singular values). "
"Sparsity is achieved by truncating Pauli matrices. Sparsity settings "
"alternate the singular values due to truncation. :param N: size of matrix"
" :type N: int :param sings: list of N singular values."
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:7
msgid "Overrides K, srange."
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:9
msgid ""
"condition number. Either use only condition number K or list/tuple of (K,"
" lmin). Where lmin specifies the smallest singular value."
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:13
msgid "[min, max] list for singular value range, min >= 0. (default=[0, 1])."
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:16
msgid "limit of Pauli matrices."
msgstr ""

#: of qiskit.aqua.utils.random_non_hermitian:21
msgid "random matrix"
msgstr ""

#: of qiskit.aqua.utils.summarize_circuits:1
msgid ""
"Summarize circuits based on QuantumCircuit, and four metrics are "
"summarized."
msgstr ""

#: of qiskit.aqua.utils.summarize_circuits:3
msgid ""
"Number of qubits and classical bits, and number of operations and depth "
"of circuits. The average statistic is provided if multiple circuits are "
"inputed."
msgstr ""

#: of qiskit.aqua.utils.summarize_circuits:6
msgid "the to-be-summarized circuits"
msgstr ""

#: of qiskit.aqua.utils.get_subsystem_density_matrix:1
msgid "Compute the reduced density matrix of a quantum subsystem."
msgstr ""

#: of qiskit.aqua.utils.get_subsystem_density_matrix:3
msgid "The state vector of the complete system"
msgstr ""

#: of qiskit.aqua.utils.get_subsystem_density_matrix:5
msgid "The indices of the qubits to be traced out."
msgstr ""

#: of qiskit.aqua.utils.get_subsystem_density_matrix:8
msgid "The reduced density matrix for the desired subsystem"
msgstr ""

#: of qiskit.aqua.utils.get_subsystems_counts:1
msgid ""
"Extract all subsystems' counts from the single complete system count "
"dictionary."
msgstr ""

#: of qiskit.aqua.utils.get_subsystems_counts:3
msgid ""
"If multiple classical registers are used to measure various parts of a "
"quantum system, Each of the measurement dictionary's keys would contain "
"spaces as delimiters to separate the various parts being measured. For "
"example, you might have three keys '11 010', '01 011' and '11 011', among"
" many other, in the count dictionary of the 5-qubit complete system, and "
"would like to get the two subsystems' counts (one 2-qubit, and the other "
"3-qubit) in order to get the counts for the 2-qubit partial measurement "
"'11' or the 3-qubit partial measurement '011'."
msgstr ""

#: of qiskit.aqua.utils.get_subsystems_counts:12
msgid ""
"The measurement count dictionary of a complete system that contains "
"multiple classical registers for measurements s.t. the dictionary's keys "
"have space delimiters."
msgstr ""

#: of qiskit.aqua.utils.get_subsystems_counts:17
msgid ""
"A list of measurement count dictionaries corresponding to each of the "
"subsystems measured."
msgstr ""

#: of qiskit.aqua.utils.get_entangler_map:1
msgid "Utility method to get an entangler map among qubits."
msgstr ""

#: of qiskit.aqua.utils.get_entangler_map:3
msgid ""
"'full' entangles each qubit with all the subsequent ones 'linear' "
"entangles each qubit with the next"
msgstr ""

#: of qiskit.aqua.utils.get_entangler_map:6
msgid "Number of qubits for which the map is needed"
msgstr ""

#: of qiskit.aqua.utils.get_entangler_map:9
msgid ""
"A map of qubit index to an array of indexes to which this should be "
"entangled"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter
#: qiskit.aqua.utils.compile_and_run_circuits
#: qiskit.aqua.utils.compile_circuits qiskit.aqua.utils.get_entangler_map
#: qiskit.aqua.utils.run_qobjs qiskit.aqua.utils.validate_entangler_map
msgid "raises"
msgstr ""

#: of qiskit.aqua.utils.get_entangler_map:11
msgid ":exc:`ValueError` -- if map_type is not valid."
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:1
msgid "Validate a user supplied entangler map and converts entries to ints."
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:3
msgid ""
"An entangler map, keys are source qubit index (int), value is array of "
"target qubit index(es) (int)"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:6
msgid "Number of qubits"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:8
msgid "If we allow in two qubits can be entangled each other"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:10
msgid "Validated/converted map"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:12
msgid ":exc:`TypeError` -- entangler map is not list type or list of list"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:13
msgid ":exc:`ValueError` -- the index of entangler map is out of range"
msgstr ""

#: of qiskit.aqua.utils.validate_entangler_map:14
msgid ":exc:`ValueError` -- the qubits are cross-entangled."
msgstr ""

#: of qiskit.aqua.utils.get_feature_dimension:1
msgid "Check feature dimension of a given dataset"
msgstr ""

#: of qiskit.aqua.utils.get_feature_dimension:3
#: qiskit.aqua.utils.get_num_classes:3
msgid "key is the class name and value is the data."
msgstr ""

#: of qiskit.aqua.utils.get_feature_dimension:6
msgid "feature dimension, -1 denotes no data in the dataset."
msgstr ""

#: of qiskit.aqua.utils.get_num_classes:1
msgid "Check number of classes in a given dataset"
msgstr ""

#: of qiskit.aqua.utils.get_num_classes:6
msgid "number of classes"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:1
msgid "Split dataset to data and labels numpy array"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:3
msgid ""
"If `class_names` is given, use the desired label to class name mapping, "
"or create the mapping based on the keys in the dataset."
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:6
msgid "{'A': numpy.ndarray, 'B': numpy.ndarray, ...}"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:8
msgid "class name of dataset, {class_name: label}"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:11
msgid ""
"idx 0 is data, NxD array,             idx 1 is labels, Nx1 array, value "
"is ranged             from 0 to K-1, K is the number of classes dict: "
"{str: int}, map from class name to label"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:14
msgid "idx 0 is data, NxD array,"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:14
msgid ""
"idx 1 is labels, Nx1 array, value is ranged from 0 to K-1, K is the "
"number of classes"
msgstr ""

#: of qiskit.aqua.utils.split_dataset_to_data_and_labels:16
msgid "dict: {str: int}, map from class name to label"
msgstr ""

#: of qiskit.aqua.utils.map_label_to_class_name:1
msgid "Helper converts labels (numeric) to class name (string)"
msgstr ""

#: of qiskit.aqua.utils.map_label_to_class_name:3
#: qiskit.aqua.utils.optimize_svm:8
msgid "Nx1 array"
msgstr ""

#: of qiskit.aqua.utils.map_label_to_class_name:5
msgid "a mapping form label (numeric) to class name (str)"
msgstr ""

#: of qiskit.aqua.utils.map_label_to_class_name:8
msgid "predicted class names of each datum"
msgstr ""

#: of qiskit.aqua.utils.reduce_dim_to_via_pca:1
msgid "Reduce the data dimension via pca"
msgstr ""

#: of qiskit.aqua.utils.reduce_dim_to_via_pca:3
msgid "NxD array"
msgstr ""

#: of qiskit.aqua.utils.reduce_dim_to_via_pca:5
msgid "the targeted dimension D'"
msgstr ""

#: of qiskit.aqua.utils.reduce_dim_to_via_pca:8
msgid "NxD' array"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:1
msgid ""
"Solving quadratic programming problem for SVM; thus, some constraints are"
" fixed."
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:3
msgid ""
"The notation is follows the equation here: "
"http://cvxopt.org/userguide/coneprog.html#quadratic-programming"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:6
msgid "NxN array"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:10
msgid ""
"the scaling factor to renormalize the `y`, if it is None, use L2-norm of "
"`y` for normalization"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:13
msgid "number of iterations for QP solver"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:15
msgid "showing the progress of QP solver"
msgstr ""

#: of qiskit.aqua.utils.optimize_svm:18
msgid ""
"Sx1 array, where S is the number of supports numpy.ndarray: Sx1 array, "
"where S is the number of supports numpy.ndarray: Sx1 array, where S is "
"the number of supports"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory:1
msgid "ベースクラス: :class:`abc.ABC`"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory:1
msgid "Base class for CircuitFactories"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build:1
msgid "Adds corresponding sub-circuit to given circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build:3
#: qiskit.aqua.utils.CircuitFactory.build_controlled:3
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:3
#: qiskit.aqua.utils.CircuitFactory.build_inverse:3
msgid "quantum circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build:4
#: qiskit.aqua.utils.CircuitFactory.build_controlled:4
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:4
#: qiskit.aqua.utils.CircuitFactory.build_inverse:4
msgid "list of qubits (has to be same length as self._num_qubits)"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build:5
#: qiskit.aqua.utils.CircuitFactory.build_controlled:6
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:6
#: qiskit.aqua.utils.CircuitFactory.build_inverse:5
msgid "list of ancilla qubits (or None if none needed)"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build:6
#: qiskit.aqua.utils.CircuitFactory.build_inverse:6
msgid "parameters for circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled:1
msgid "Adds corresponding controlled sub-circuit to given circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled:5
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:5
msgid "control qubit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled:7
#: qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:7
msgid "use basis gates for expansion of controlled circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled_inverse:1
msgid "Adds controlled inverse of corresponding sub-circuit to given circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled_inverse_power:1
msgid ""
"Adds controlled, inverse, power of corresponding circuit. May be "
"overridden if a more efficient implementation is possible"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_controlled_power:1
msgid ""
"Adds controlled power of corresponding circuit. May be overridden if a "
"more efficient implementation is possible"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_inverse:1
msgid "Adds inverse of corresponding sub-circuit to given circuit"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_inverse_power:1
msgid ""
"Adds inverse power of corresponding circuit. May be overridden if a more "
"efficient implementation is possible"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.build_power:1
msgid ""
"Adds power of corresponding circuit. May be overridden if a more "
"efficient implementation is possible"
msgstr ""

#: of qiskit.aqua.utils.CircuitFactory.num_target_qubits:1
msgid "Returns the number of target qubits"
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:1
#: qiskit.aqua.utils.compile_circuits:1 qiskit.aqua.utils.run_qobjs:1
msgid "An execution wrapper with Qiskit-Terra, with job auto recover capability."
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:3
#: qiskit.aqua.utils.compile_circuits:3 qiskit.aqua.utils.run_qobjs:3
msgid ""
"The autorecovery feature is only applied for non-simulator backend. This "
"wraper will try to get the result no matter how long it costs."
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:6
#: qiskit.aqua.utils.compile_circuits:6
msgid "circuits to execute"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:5
#: qiskit.aqua.utils.compile_and_run_circuits:8
#: qiskit.aqua.utils.compile_circuits:8 qiskit.aqua.utils.run_qobjs:8
msgid "backend instance"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:7
#: qiskit.aqua.utils.compile_and_run_circuits:10
#: qiskit.aqua.utils.compile_circuits:10
msgid "configuration for backend"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:9
#: qiskit.aqua.utils.compile_and_run_circuits:12
#: qiskit.aqua.utils.compile_circuits:12
msgid "configuration for compilation"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:11
#: qiskit.aqua.utils.compile_and_run_circuits:14
#: qiskit.aqua.utils.compile_circuits:14
msgid "configuration for running a circuit"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:13
#: qiskit.aqua.utils.compile_and_run_circuits:16 qiskit.aqua.utils.run_qobjs:10
msgid "configuration for quantum job object"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:15
#: qiskit.aqua.utils.compile_and_run_circuits:18 qiskit.aqua.utils.run_qobjs:12
msgid "configuration for simulator"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:17
#: qiskit.aqua.utils.compile_and_run_circuits:20 qiskit.aqua.utils.run_qobjs:14
msgid "configuration for noise model"
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:22
#: qiskit.aqua.utils.compile_circuits:16
msgid "showing the summary of submitted circuits."
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:24
#: qiskit.aqua.utils.compile_circuits:18
msgid "A CircuitCache to use when calling compile_and_run_circuits"
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:26
#: qiskit.aqua.utils.run_qobjs:16
msgid "Bypass Qobj validation to decrease submission time"
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:29
#: qiskit.aqua.utils.run_qobjs:19
msgid "Result object"
msgstr ""

#: of qiskit.aqua.utils.compile_and_run_circuits:32
#: qiskit.aqua.utils.compile_circuits:24 qiskit.aqua.utils.run_qobjs:22
msgid ":exc:`AquaError` -- Any error except for JobError raised by Qiskit Terra"
msgstr ""

#: of qiskit.aqua.utils.compile_circuits:21
msgid "compiled qobj."
msgstr ""

#: of qiskit.aqua.utils.run_qobjs:6
msgid "qobjs to execute"
msgstr ""

#: of qiskit.aqua.utils.find_regs_by_name:1
msgid "Find the registers in the circuits."
msgstr ""

#: of qiskit.aqua.utils.find_regs_by_name:3
msgid "the quantum circuit."
msgstr ""

#: of qiskit.aqua.utils.find_regs_by_name:5
msgid "name of register"
msgstr ""

#: of qiskit.aqua.utils.find_regs_by_name:7
msgid "quantum or classical register"
msgstr ""

#: of qiskit.aqua.utils.find_regs_by_name:10
msgid "if not found, return None."
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit:1
msgid ""
"A method for caching compiled qobjs by storing the compiled qobj and "
"constructing a mapping array from the uncompiled operations in the "
"circuit to the instructions in the qobj. Note that the \"qobjs\" list in "
"the cache dict is a list of the cached chunks, each element of which "
"contains a single qobj with as many experiments as is allowed by the "
"execution backend. E.g. if the backend allows 300 experiments per job and"
" the user wants to run 500 circuits, len(circuit_cache['qobjs']) == 2, "
"len(circuit_cache['qobjs'][0].experiments) == 300, and "
"len(circuit_cache['qobjs'][1].experiments) == 200."
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit:11
msgid ""
"This feature is only applied if 'circuit_caching' is True in the "
"'problem' Aqua dictionary section."
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit:14
msgid "A compiled qobj to be saved"
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit:16
msgid "The original uncompiled QuantumCircuits"
msgstr ""

#: of qiskit.aqua.utils.CircuitCache.cache_circuit:18
msgid ""
"If a larger list of circuits was broken into chunks by run_algorithm for "
"separate runs,"
msgstr ""

#: of qiskit.aqua.utils.get_measured_qubits_from_qobj:1
msgid "Retrieve the measured qubits from transpiled circuits."
msgstr ""

#: of qiskit.aqua.utils.get_measured_qubits_from_qobj:3
msgid "qobjs"
msgstr ""

#: of qiskit.aqua.utils.get_measured_qubits_from_qobj:6
msgid "the qubit mapping to-be-used for measure error mitigation"
msgstr ""

#: of qiskit.aqua.utils.mitigate_measurement_error:1
msgid "the unmitigated Result object"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:20
#: qiskit.aqua.utils.mitigate_measurement_error:3
msgid "the measurement fitter"
msgstr ""

#: of qiskit.aqua.utils.mitigate_measurement_error:5
msgid ""
"fitting method. If None, then least_squares is used. 'pseudo_inverse': "
"direct inversion of the A matrix 'least_squares': constrained to have "
"physical probabilities"
msgstr ""

#: of qiskit.aqua.utils.mitigate_measurement_error:10
msgid "the mitigated Result"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:1
msgid "the measured qubit index (in the order to classical bit 0...n-1)"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:3
msgid "CompleteMeasFitter or TensoredMeasFitter"
msgstr ""

#: of qiskit.aqua.utils.build_measurement_error_mitigation_fitter:23
msgid ":exc:`AquaError` -- when the fitter_cls is not recognizable."
msgstr ""

#: ../../autodoc/qiskit.aqua.utils.rst:10
msgid "Submodules"
msgstr ""

