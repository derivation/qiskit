msgid ""
msgstr ""
"Project-Id-Version: qiskittranslation\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-05 16:34+0000\n"
"PO-Revision-Date: 2019-06-05 16:56\n"
"Last-Translator: Soolu\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: crowdin.com\n"
"X-Crowdin-Project: qiskittranslation\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /poRepo/docs/locale/locale/ja/LC_MESSAGES/ja/aqua/algorithms.po\n"
"Language: ja_JP\n"

#: ../../../aqua/algorithms.rst:5
msgid "Algorithms"
msgstr ""

#: ../../../aqua/algorithms.rst:7
msgid "Aqua is an extensible collection of algorithms and utilities for use with quantum computers to carry out research and investigate how to solve problems using near-term quantum applications on short depth circuits. The applications can span different domains. Aqua uses `Terra <https://www.qiskit.org/terra>`__ for the generation, compilation and execution of the quantum circuits modeling the specific problems."
msgstr ""

#: ../../../aqua/algorithms.rst:14
msgid "The following `quantum algorithms <#quantum-algorithms>`__ are part of Aqua:"
msgstr ""

#: ../../../aqua/algorithms.rst:16
msgid ":ref:`Variational Quantum Eigensolver (VQE)`"
msgstr ""

#: ../../../aqua/algorithms.rst:17
msgid ":ref:`Quantum Approximate Optimization Algorithm (QAOA)`"
msgstr ""

#: ../../../aqua/algorithms.rst:18
msgid ":ref:`Evolution of Hamiltonian (EOH)`"
msgstr ""

#: ../../../aqua/algorithms.rst:19
msgid ":ref:`Quantum Phase Estimation (QPE)`"
msgstr ""

#: ../../../aqua/algorithms.rst:20
msgid ":ref:`Iterative Quantum Phase Estimation (IQPE)`"
msgstr ""

#: ../../../aqua/algorithms.rst:21
msgid ":ref:`Amplitude Estimation`"
msgstr ""

#: ../../../aqua/algorithms.rst:22
msgid ":ref:`Quantum Grover Search`"
msgstr ""

#: ../../../aqua/algorithms.rst:23
msgid ":ref:`Deutsch Jozsa`"
msgstr ""

#: ../../../aqua/algorithms.rst:24
msgid ":ref:`Bernstein Vazirani`"
msgstr ""

#: ../../../aqua/algorithms.rst:25
msgid ":ref:`Simon`"
msgstr ""

#: ../../../aqua/algorithms.rst:26
msgid ":ref:`Quantum Support Vector Machine (QSVM)`"
msgstr ""

#: ../../../aqua/algorithms.rst:27
msgid ":ref:`Variational Quantum Classifier (VQC)`"
msgstr ""

#: ../../../aqua/algorithms.rst:28
msgid ":ref:`HHL algorithm for solving linear systems (HHL)`"
msgstr ""

#: ../../../aqua/algorithms.rst:29
msgid ":ref:`Shor's Factoring Algorithm`"
msgstr ""

#: ../../../aqua/algorithms.rst:30
msgid ":ref:`Quantum Generative Adversarial Network (qGAN)`"
msgstr ""

#: ../../../aqua/algorithms.rst:32
msgid "Aqua includes  also some `classical algorithms <#classical-reference-algorithms>`__ for generating reference values. This feature of Aqua may be useful to quantum algorithm researchers interested in generating, comparing and contrasting results in the near term while experimenting with, developing and testing quantum algorithms:"
msgstr ""

#: ../../../aqua/algorithms.rst:38
msgid ":ref:`Exact Eigensolver`"
msgstr ""

#: ../../../aqua/algorithms.rst:39
msgid ":ref:`Exact LSsolver`"
msgstr ""

#: ../../../aqua/algorithms.rst:40
msgid ":ref:`CPLEX Ising`"
msgstr ""

#: ../../../aqua/algorithms.rst:41
msgid ":ref:`Support Vector Machine Radial Basis Function Kernel (SVM Classical)`"
msgstr ""

msgid "Extending the Algorithm Library"
msgstr ""

#: ../../../aqua/algorithms.rst:45
msgid "Algorithms and many of the components they use have been designed to be pluggable. A new algorithm may be developed according to the specific Application Programming Interface (API) provided by Aqua, and by simply adding its code to the collection of existing algorithms, that new algorithm  will be immediately recognized via dynamic lookup, and made available for use within the framework of Aqua. Specifically, to develop and deploy any new algorithm, the new algorithm class should derive from the ``QuantumAlgorithm`` class. Along with any supporting  module, for immediate dynamic discovery, the new algorithm class can simply be placed in an appropriate folder in the ``qiskit_aqua\\algorithms`` directory, just like the existing algorithms.  Aqua also allows for :ref:`aqua-dynamically-discovered-components`: new components can register themselves as Aqua extensions and be dynamically discovered at run time independent of their location in the file system. This is done in order to encourage researchers and developers interested in :ref:`aqua-extending` to extend the Aqua framework with their novel research contributions."
msgstr ""

#: ../../../aqua/algorithms.rst:64
msgid "Section :ref:`aqua-extending` provides more details on how to extend Aqua with new components."
msgstr ""

#: ../../../aqua/algorithms.rst:72
msgid "Quantum Algorithms"
msgstr ""

#: ../../../aqua/algorithms.rst:74
msgid "In this section, we describe the quantum algorithms currently available in Aqua."
msgstr ""

#: ../../../aqua/algorithms.rst:78
msgid "Aqua requires associating a quantum device or simulator to any experiment that uses a quantum algorithm.  This is done by configuring the ``\"backend\"`` section of the experiment to be run. Consult the documentation on the :ref:`aqua-input-file` for more details."
msgstr ""

#: ../../../aqua/algorithms.rst:86
msgid "Variational Quantum Eigensolver (VQE)"
msgstr ""

#: ../../../aqua/algorithms.rst:88
msgid "`VQE <https://arxiv.org/abs/1304.3061>`__ is a hybrid algorithm that uses the variational approach and interleaves quantum and classical computations in order to find the minimum eigenvalue of the Hamiltonian :math:`H` of a given system. An instance of VQE requires defining two algorithmic subcomponents: a trial function from Aqua's :ref:`variational-forms` library, and a classical optimizer from Aqua's :ref:`optimizers` library.  An initial state from Aqua's :ref:`initial-states` library may be supplied too in order to define the starting state for the trial function."
msgstr ""

#: ../../../aqua/algorithms.rst:99
msgid "Refer to the documentation of :ref:`variational-forms`, :ref:`optimizers` and :ref:`initial-states` for more details."
msgstr ""

#: ../../../aqua/algorithms.rst:102
msgid "Additionally, VQE can be configured with the following parameters:"
msgstr ""

#: ../../../aqua/algorithms.rst:104 ../../../aqua/algorithms.rst:168
msgid "A ``str`` value indicating the mode used by the ``Operator`` class for the computation:"
msgstr ""

#: ../../../aqua/algorithms.rst:110 ../../../aqua/algorithms.rst:174
msgid "If no value for ``operator_mode`` is specified, the default is ``\"matrix\"``."
msgstr ""

#: ../../../aqua/algorithms.rst:112 ../../../aqua/algorithms.rst:184
msgid "The initial point for the search of the minimum eigenvalue:"
msgstr ""

#: ../../../aqua/algorithms.rst:118
msgid "An optional list of ``float`` values  may be provided as the starting point for the search of the minimum eigenvalue. This feature is particularly useful when there are reasons to believe that the solution point is close to a particular point, which can then be provided as the preferred initial point.  As an example, when building the dissociation profile of a molecule, it is likely that using the previous computed optimal solution as the starting initial point for the next interatomic distance is going to reduce the number of iterations necessary for the variational algorithm to converge.  Aqua provides `a tutorial detailing this use case <https://github.com/Qiskit/aqua-tutorials/blob/master/chemistry/h2_vqe_initial_point.ipynb>`__."
msgstr ""

#: ../../../aqua/algorithms.rst:126
msgid "The length of the ``initial_point`` list value must match the number of the parameters expected by the variational form being used. If the user does not supply a preferred initial point, then VQE will look to the variational form for a preferred value. If the variational form returns ``None``, then a random point will be generated within the parameter bounds set, as per above. If the variational form provides ``None`` as the lower bound, then VQE will default it to :math:`-2\\pi`; similarly, if the variational form returns ``None`` as the upper bound, the default value will be :math:`2\\pi`."
msgstr ""

msgid "Declarative Name"
msgstr ""

#: ../../../aqua/algorithms.rst:136
msgid "When referring to VQE declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``VQE``."
msgstr ""

msgid "Problems Supported"
msgstr ""

#: ../../../aqua/algorithms.rst:141
msgid "In Aqua, VQE supports the ``energy`` and ``ising`` problems."
msgstr ""

#: ../../../aqua/algorithms.rst:147
msgid "Quantum Approximate Optimization Algorithm (QAOA)"
msgstr ""

#: ../../../aqua/algorithms.rst:149
msgid "`QAOA <https://arxiv.org/abs/1411.4028>`__ is a well-known algorithm for finding approximate solutions to combinatorial-optimization problems. The QAOA implementation in Aqua directly uses `VQE <#variational-quantum-eigensolver-vqe>`__ for its general hybrid optimization structure. However, unlike VQE, which can be configured with arbitrary variational forms, QAOA uses its own fine-tuned variational form, which comprises :math:`p` parameterized global :math:`x` rotations and :math:`p` different parameterizations of the problem hamiltonian. As a result, unlike VQE, QAOA does not need to have a variational form specified as an input parameter, and is configured mainly by a single integer parameter, ``p``, which dictates the depth of the variational form, and thus affects the approximation quality. An initial state from Aqua's :ref:`initial-states` library may be supplied as well."
msgstr ""

#: ../../../aqua/algorithms.rst:164
msgid "Consult the documentation on :ref:`optimizers` and :ref:`initial-states` for more details."
msgstr ""

#: ../../../aqua/algorithms.rst:166
msgid "In summary, QAOA can be configured with the following parameters:"
msgstr ""

#: ../../../aqua/algorithms.rst:176
msgid "A positive ``int`` value configuring the QAOA variational form depth, as discussed above:"
msgstr ""

#: ../../../aqua/algorithms.rst:182
msgid "This has to be a positive ``int`` value.  The default is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:190
msgid "An optional list of :math:`2p` ``float`` values  may be provided as the starting ``beta`` and ``gamma`` parameters (as identically named in the original `QAOA paper <https://arxiv.org/abs/1411.4028>`__) for the QAOA variational form. If such list is not provided, QAOA will simply start with the all-zero vector."
msgstr ""

#: ../../../aqua/algorithms.rst:194
msgid "An optional ``Operator`` may be provided as a custom mixer Hamiltonian. This allows, as discussed in `this paper <https://doi.org/10.1103/PhysRevApplied.5.034007>` for quantum annealing, and in `this paper <https://arxiv.org/abs/1709.03489>` for QAOA, to run constrained optimization problems where the mixer constrains the evolution to a feasible subspace of the full Hilbert space."
msgstr ""

#: ../../../aqua/algorithms.rst:199
msgid "Similar to VQE, an optimizer may also be specified."
msgstr ""

#: ../../../aqua/algorithms.rst:203
msgid "When referring to QAOA declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``QAOA.Variational``."
msgstr ""

#: ../../../aqua/algorithms.rst:209
msgid "In Aqua, QAOA supports the ``ising`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:215
msgid "Evolution of Hamiltonian (EOH)"
msgstr ""

#: ../../../aqua/algorithms.rst:217
msgid "EOH provides the lower-level building blocks for simulating universal quantum systems. For any given quantum system that can be decomposed into local interactions (for example, a global hamiltonian as the weighted sum of several Pauli spin operators), the local interactions can then be used to approximate the global quantum system via, for example, Lloyd’s method or Trotter-Suzuki decomposition."
msgstr ""

#: ../../../aqua/algorithms.rst:226
msgid "This algorithm only supports the local state vector simulator."
msgstr ""

#: ../../../aqua/algorithms.rst:228
msgid "EOH can be configured with the following parameter settings:"
msgstr ""

#: ../../../aqua/algorithms.rst:230
msgid "Evolution time:"
msgstr ""

#: ../../../aqua/algorithms.rst:236
msgid "A ``float`` value is expected.  The minimum value is ``0.0``.  The default value is ``1.0``."
msgstr ""

#: ../../../aqua/algorithms.rst:238
msgid "The evolution mode of the computation:"
msgstr ""

#: ../../../aqua/algorithms.rst:244
msgid "Two ``str`` values are permitted: ``\"matrix\"`` or ``\"circuit\"``, with ``\"circuit\"`` being the default."
msgstr ""

#: ../../../aqua/algorithms.rst:246 ../../../aqua/algorithms.rst:309
msgid "The number of time slices:"
msgstr ""

#: ../../../aqua/algorithms.rst:252
msgid "This has to be a non-negative ``int`` value.  The default is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:254 ../../../aqua/algorithms.rst:317
msgid "The expansion mode:"
msgstr ""

#: ../../../aqua/algorithms.rst:260 ../../../aqua/algorithms.rst:323
msgid "Two ``str`` values are permitted: ``\"trotter\"`` (Lloyd's method) or ``\"suzuki\"`` (for Trotter-Suzuki expansion), with  ``\"trotter\"`` being the default one."
msgstr ""

#: ../../../aqua/algorithms.rst:263 ../../../aqua/algorithms.rst:327
msgid "The expansion order:"
msgstr ""

#: ../../../aqua/algorithms.rst:269
msgid "This parameter sets the Trotter-Suzuki expansion order.  A positive ``int`` value is expected.  The default value is ``2``."
msgstr ""

#: ../../../aqua/algorithms.rst:273
msgid "When referring to EOH declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``EOH``."
msgstr ""

#: ../../../aqua/algorithms.rst:278
msgid "In Aqua, EOH supports the ``eoh`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:284
msgid "Quantum Phase Estimation (QPE)"
msgstr ""

#: ../../../aqua/algorithms.rst:286
msgid "QPE (also sometimes abbreviated as PEA, for *Phase Estimation Algorithm*), takes two quantum registers, *control* and *target*, where the control consists of several qubits initially put in uniform superposition, and the target a set of qubits prepared in an eigenstate (or, oftentimes, a guess of the eigenstate) of the unitary operator of a quantum system. QPE then evolves the target under the control using :ref:`Dynamics` on the unitary operator. The information of the corresponding eigenvalue is then *kicked-back* into the phases of the control register, which can then be deconvoluted by an Inverse Quantum Fourier Transform (IQFT), and measured for read-out in binary decimal format.  QPE also requires a reasonably good estimate of the eigen wave function to start the process. For example, when estimating molecular ground energies, the :ref:`Hartree-Fock` method could be used to provide such trial eigen wave functions."
msgstr ""

#: ../../../aqua/algorithms.rst:303
msgid "Consult the documentation on :ref:`iqfts` and :ref:`initial-states` for more details."
msgstr ""

#: ../../../aqua/algorithms.rst:306
msgid "In addition to requiring an IQFT and an initial state as part of its configuration, QPE also exposes the following parameter settings:"
msgstr ""

#: ../../../aqua/algorithms.rst:315
msgid "This has to be a non-negative ``int`` value.  The default value is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:333
msgid "This parameter sets the Trotter-Suzuki expansion order.  A positive ``int`` value is expected. The default value is ``2``."
msgstr ""

#: ../../../aqua/algorithms.rst:336
msgid "The number of ancillae:"
msgstr ""

#: ../../../aqua/algorithms.rst:342
msgid "This parameter sets the number of ancillary qubits to be used by QPE.  A positive ``int`` value is expected. The default value is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:347
msgid "When referring to QPE declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``QPE``."
msgstr ""

#: ../../../aqua/algorithms.rst:352
msgid "In Aqua, QPE supports the ``energy`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:358
msgid "Iterative Quantum Phase Estimation (IQPE)"
msgstr ""

#: ../../../aqua/algorithms.rst:360
msgid "IQPE, as its name suggests, iteratively computes the phase so as to require fewer qubits. It takes in the same set of parameters as `QPE <#quantum-phase-estimation-qpe>`__, except for the number of ancillary qubits ``num_ancillae``, which is replaced by ``num_iterations`` (a positive ``int``, also defaulted to ``1``), and for the fact that an Inverse Quantum Fourier Transform (IQFT) is not used for IQPE."
msgstr ""

#: ../../../aqua/algorithms.rst:370
msgid "For more details, please see `arXiv:quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`__."
msgstr ""

#: ../../../aqua/algorithms.rst:374
msgid "When referring to IQPE declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``IQPE``."
msgstr ""

#: ../../../aqua/algorithms.rst:379
msgid "In Aqua, IQPE supports the ``energy`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:386
msgid "Amplitude Estimation"
msgstr ""

#: ../../../aqua/algorithms.rst:388
msgid "*Amplitude Estimation* is a derivative of -  :ref:`Quantum Phase Estimation (QPE)` applied to a particular operator :math:`A`. :math:`A` is assumed to operate on :math:`n + 1` qubits (plus possible ancillary qubits) where the :math:`n` qubits represent the uncertainty (in the form of a random distribution from the :ref:`random-distributions` library) and the last qubit, called the *objective qubit*, is used to represent the normalized objective value as its amplitude. In other words, :math:`A` is constructed such that the probability of measuring a '1' in the objective qubit is equal to the value of interest."
msgstr ""

#: ../../../aqua/algorithms.rst:402
msgid "Consult the documentation on -  :ref:`Quantum Phase Estimation (QPE)` for more details. Also, see `arXiv:1806.06893 <https://arxiv.org/abs/1806.06893>`_ for more details on Amplitude Estimation as well as its applications on finance problems."
msgstr ""

#: ../../../aqua/algorithms.rst:406
msgid "In addition to relying on a ``QPE`` component for building the Quantum Phase Estimation circuit, in order to be properly constructed, an ``AmplitudeEstimation`` algorithm object expects the following inputs:"
msgstr ""

#: ../../../aqua/algorithms.rst:411
msgid "The number of evaluation qubits:"
msgstr ""

#: ../../../aqua/algorithms.rst:417
msgid "This has to be a positive ``int`` value."
msgstr ""

#: ../../../aqua/algorithms.rst:419
msgid "The uncertainty problem:"
msgstr ""

#: ../../../aqua/algorithms.rst:425
msgid "A ``CircuitFactory`` object that represents the uncertainty problem, i.e., the :math:`A` operator mentioned above."
msgstr ""

#: ../../../aqua/algorithms.rst:428
msgid "The optional problem unitary:"
msgstr ""

#: ../../../aqua/algorithms.rst:434
msgid "An optional ``CircuitFactory`` object that represents the problem unitary, which, if left unspecified, will be automatically constructed from the ``a_factory``."
msgstr ""

#: ../../../aqua/algorithms.rst:437
msgid "The Inverse Quantum Fourier Transform component:"
msgstr ""

#: ../../../aqua/algorithms.rst:443
msgid "The Inverse Quantum Fourier Transform pluggable component that's to be used to configure the ``PhaseEstimation`` component. The standard iqft will be used by default if left None."
msgstr ""

#: ../../../aqua/algorithms.rst:449
msgid "When referring to Amplitude Estimation declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``AmplitudeEstimation``."
msgstr ""

#: ../../../aqua/algorithms.rst:454
msgid "In Aqua, Amplitude Estimation supports the ``uncertainty`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:461
msgid "Quantum Grover Search"
msgstr ""

#: ../../../aqua/algorithms.rst:463
msgid "Grover’s Search is a well known quantum algorithm for searching through unstructured collections of records for particular targets with quadratic speedup compared to classical algorithms."
msgstr ""

#: ../../../aqua/algorithms.rst:467
msgid "Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}` and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal on an *unstructured-search problem* is to find an element :math:`x^* \\in X` such that :math:`f(x^*)=1`. Unstructured search is often alternatively formulated as a database search problem, in which, given a database, the goal is to find in it an item that meets some specification. The search is called *unstructured* because there are no guarantees as to how the database is ordered.  On a sorted database, for instance, one could perform binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time. Instead, in an unstructured-search problem, there is no prior knowledge about the contents of the database. With classical circuits, there is no alternative but to perform a linear number of queries to find the target element. Conversely, Grover's Search algorithm allows to solve the unstructured-search problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries."
msgstr ""

#: ../../../aqua/algorithms.rst:483
msgid "All that is needed for carrying out a search is an Grover oracle from Aqua's :ref:`oracles` library for specifying the search criterion, which basically indicates a hit or miss for any given record.  More formally, an *oracle* :math:`O_f` is an object implementing a boolean function :math:`f` as specified above.  Given an input :math:`x \\in X`, :math:`O_f` implements :math:`f(x)`.  The details of how :math:`O_f` works are unimportant; Grover's search algorithm treats the oracle as a black box. Currently, Aqua provides a :ref:`logic_expr_oracle` and a :ref:`truth_table_oracle`, both of which can be used in Grover's search tasks. In particular, the :ref:`logic_expr_oracle` can take as input a SAT problem instance in `DIMACS CNF format <http://www.satcompetition.org/2009/format-benchmarks2009.html>`__ and constructs the corresponding quantum circuit, which can then be fed to the Grover algorithm to find a satisfiable assignment."
msgstr ""

#: ../../../aqua/algorithms.rst:499
msgid "Oracles are treated as pluggable components in Aqua; researchers interested in :ref:`aqua-extending` can design and implement new oracles and extend Aqua's oracle library."
msgstr ""

#: ../../../aqua/algorithms.rst:504
msgid "Grover's Search by default uses uniform superposition to initialize its quantum state. However, an initial state from Aqua's :ref:`initial-states` library may be supplied to create any starting quantum state. This could be useful, for example, if the user already has some prior knowledge regarding where the search target(s) might be located."
msgstr ""

#: ../../../aqua/algorithms.rst:514
msgid "Refer to the documentation :ref:`initial-states` for more details."
msgstr ""

#: ../../../aqua/algorithms.rst:517
msgid "Grover can also be configured with the following parameter settings:"
msgstr ""

#: ../../../aqua/algorithms.rst:519
msgid "Number of iterations:"
msgstr ""

#: ../../../aqua/algorithms.rst:525
msgid "For the conventional Grover's search algorithm, the parameter ``num_iterations`` is used to specify how many times the marking and reflection phase sub-circuit is repeated to amplify the amplitude(s) of the target(s). A positive ``int`` value is expected. The default value is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:531
msgid "Incremental mode flag:"
msgstr ""

#: ../../../aqua/algorithms.rst:537
msgid "When run in ``incremental`` mode, the search task will be carried out in successive rounds, using circuits built with incrementally higher number of iterations for the repetition of the amplitude amplification until a target is found or the maximal number :math:`\\log N` (:math:`N` being the total number of elements in the set from the oracle used) of iterations is reached. The implementation follows Section 4 of `Boyer et al. <https://arxiv.org/abs/quant-ph/9605034>`__ The ``incremental`` boolean flag defaults to ``False``. When set ``True``, the other parameter ``num_iterations`` will be ignored."
msgstr ""

#: ../../../aqua/algorithms.rst:551
msgid "When referring to Quantum Grover Search declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``Grover``."
msgstr ""

#: ../../../aqua/algorithms.rst:556
msgid "In Aqua, Grover's Search algorithm supports the ``search`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:562
msgid "Deutsch-Jozsa"
msgstr ""

#: ../../../aqua/algorithms.rst:564
msgid "The Deutsch-Jozsa algorithm was one of the first known quantum algorithms that showed an exponential speedup compared to a deterministic (non-probabilistic) classical algorithm, given a black box oracle function. The algorithm determines whether the given function :math:`f:\\{0,1\\}^n \\rightarrow \\{0,1\\}` is constant or balanced. A constant function maps all inputs to 0 or 1, and a balanced function maps half of its inputs to 0 and the other half to 1. Any of the oracles provided by Aqua can be used with the Deutsch-Jozsa algorithm, as long as the boolean function implemented by the oracle indeed satisfies the constraint of being either constant or balanced. Above said, a :ref:`truth-table-oracle` instance might be easier to construct to meet the constraint, but a :ref:`logical-expression-oracle` can certainly also be used."
msgstr ""

#: ../../../aqua/algorithms.rst:578
msgid "When referring to Deutsch-Jozsa declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``DeutschJozsa``."
msgstr ""

#: ../../../aqua/algorithms.rst:584
msgid "In Aqua, the Deutsch-Jozsa algorithm supports the ``functionevaluation`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:591
msgid "Bernstein-Vazirani"
msgstr ""

#: ../../../aqua/algorithms.rst:593
msgid "The Bernstein-Vazirani algorithm is an extension / restriction of the Deutsch-Jozsa algorithm. The goal of the algorithm is to determine a secret string :math:`s \\in \\{0,1\\}^n`, given a black box oracle function that maps :math:`f:\\{0,1\\}^n \\rightarrow \\{0,1\\}` such that :math:`f(x)=s \\cdot x (\\bmod 2)`."
msgstr ""

#: ../../../aqua/algorithms.rst:601
msgid "When referring to Bernstein-Vazirani declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``BernsteinVazirani``."
msgstr ""

#: ../../../aqua/algorithms.rst:607
msgid "In Aqua, the Bernstein-Vazirani algorithm supports the ``hiddenstringfinding`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:614
msgid "Simon"
msgstr ""

#: ../../../aqua/algorithms.rst:616
msgid "The Simon algorithm finds a hidden integer :math:`s \\in \\{0,1\\}^n` from an oracle :math:`f_s` that satisfies :math:`f_s(x) = f_s(y)` if and only if :math:`y=x \\oplus s` for all :math:`x \\in \\{0,1\\}^n`. Thus, if :math:`s = 0\\ldots 0`, i.e., the all-zero bitstring, then :math:`f_s` is a 1-to-1 (or, permutation) function. Otherwise, if :math:`s \\neq 0\\ldots 0`, then :math:`f_s` is a 2-to-1 function. Of Aqua's included oracles, :ref:`truth-table-oracle` should be the easiest to use to create one that can be used with the Simon algorith."
msgstr ""

#: ../../../aqua/algorithms.rst:628
msgid "When referring to Simon declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``Simon``."
msgstr ""

#: ../../../aqua/algorithms.rst:633
msgid "In Aqua, the Simon algorithm supports the ``periodfinding`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:639
msgid "Quantum Support Vector Machine (QSVM)"
msgstr ""

#: ../../../aqua/algorithms.rst:641
msgid "Classification algorithms and methods for machine learning are essential for pattern recognition and data mining applications. Well known techniques, such as support vector machines or neural networks, have blossomed over the last two decades as a result of the spectacular advances in classical hardware computational capabilities and speed. This progress in computer power made it possible to apply techniques theoretically developed towards the middle of the XX century on classification problems that soon became increasingly challenging."
msgstr ""

#: ../../../aqua/algorithms.rst:650
msgid "A key concept in classification methods is that of a kernel. Data cannot typically be separated by a hyperplane in its original space. A common technique used to find such a hyperplane consists on applying a non-linear transformation function to the data. This function is called a *feature map*, as it transforms the raw features, or measurable properties, of the phenomenon or subject under study. Classifying in this new feature space – and, as a matter of fact, also in any other space, including the raw original one – is nothing more than seeing how close data points are to each other. This is the same as computing the inner product for each pair of data in the set. In fact we do not need to compute the non-linear feature map for each datum, but only the inner product of each pair of data points in the new feature space. This collection of inner products is called the *kernel* and it is perfectly possible to have feature maps that are hard to compute but whose kernels are not."
msgstr ""

#: ../../../aqua/algorithms.rst:666
msgid "The QSVM algorithm applies to classification problems that require a feature map for which computing the kernel is not efficient classically. This means that the required computational resources are expected to scale exponentially with the size of the problem. QSVM uses a Quantum processor to solve this problem by a direct estimation of the kernel in the feature space. The method used falls in the category of what is called *supervised learning*, consisting of a *training phase* (where the kernel is calculated and the support vectors obtained) and a *test or classification phase* (where new labelless data is classified according to the solution found in the training phase)."
msgstr ""

#: ../../../aqua/algorithms.rst:677
msgid "QSVM can be configured with a ``bool`` parameter, indicating whether or not to print additional information when the algorithm is running:"
msgstr ""

#: ../../../aqua/algorithms.rst:684
msgid "The default is ``False``."
msgstr ""

#: ../../../aqua/algorithms.rst:688
msgid "When referring to QSVM declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``QSVM``."
msgstr ""

#: ../../../aqua/algorithms.rst:693
msgid "In Aqua, QSVM  supports the ``classification`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:699
msgid "Variational Quantum Classifier (VQC)"
msgstr ""

#: ../../../aqua/algorithms.rst:701
msgid "Similar to QSVM, the VQC algorithm also applies to classification problems. VQC uses the variational method to solve such problems in a quantum processor.  Specifically, it optimizes a parameterized quantum circuit to provide a solution that cleanly separates the data."
msgstr ""

#: ../../../aqua/algorithms.rst:707
msgid "VQC can be configured with the following parameters:"
msgstr ""

#: ../../../aqua/algorithms.rst:709
msgid "The depth of the variational circuit to be optimized:"
msgstr ""

#: ../../../aqua/algorithms.rst:715
msgid "An integer value greater than or equal to ``3`` is expected.  The default is ``3``."
msgstr ""

#: ../../../aqua/algorithms.rst:717
msgid "A Boolean indicating whether or not to print additional information when the algorithm is running:"
msgstr ""

#: ../../../aqua/algorithms.rst:724
msgid "A ``bool`` value is expected.  The default is ``False``."
msgstr ""

#: ../../../aqua/algorithms.rst:728
msgid "When referring to VQC declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``VQC``."
msgstr ""

#: ../../../aqua/algorithms.rst:733
msgid "In Aqua, VQC  supports the ``classification`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:739
msgid "HHL algorithm for solving linear systems (HHL)"
msgstr ""

#: ../../../aqua/algorithms.rst:741
msgid "The *HHL algorithm* (after the author's surnames Harrow-Hassidim-Lloyd) is a quantum algorithm to solve systems of linear equations :math:`A\\overrightarrow{x}=\\overrightarrow{b}`. Using the Quantum Phase Estimation algorithm (:ref:`QPE`), the linear system is transformed into diagonal form in which the matrix :math:`A` is easily invertible. The inversion is achieved by rotating an ancillary qubit by an angle :math:`\\arcsin{ \\frac{C}{\\lambda_\\mathrm{i}}}` around the y-axis where :math:`\\lambda_\\mathrm{i}` are the eigenvalues of :math:`A`. After uncomputing the register storing the eigenvalues using the inverse QPE, one measures the ancillary qubit. A measurement of 1 indicates that the matrix inversion succeeded. This leaves the system in a state proportional to the solution vector :math:`|x\\rangle`. In many cases one is not interested in the single vector elements of :math:`|x\\rangle` but only on certain properties. These are accessible by using problem-specific operators. Another use-case is the implementation in a larger quantum program."
msgstr ""

#: ../../../aqua/algorithms.rst:757
msgid "When HHL is executed using a dictionary non-hermitian matrices and matrices with dimensions other than :math:`2^{n}` are automatically expanded to hermitian matrices and next higher dimension :math:`2^{n}`, respectively. The returned result of the HHL algorithm for expanded matrices will be truncated."
msgstr ""

#: ../../../aqua/algorithms.rst:762
msgid "A Boolean indicating whether or not to truncate matrix and result vector from dimension :math:`2^{n}` to dimension given by ``orig_size`` by simply cutting off entries with larger indices. This parameter is set to ``True`` if HHL is executed using the dictionary approach and the input does not have dimension :math:`2^{n}`."
msgstr ""

#: ../../../aqua/algorithms.rst:772 ../../../aqua/algorithms.rst:807
msgid "A ``bool`` value is expected. The default is ``False``."
msgstr ""

#: ../../../aqua/algorithms.rst:774
msgid "An integer defining the dimension of the input matrix and vector before expansion to dimension :math:`2^{n}` has been applied. This parameter is needed if ``truncate_powerdim`` is set to ``True`` and will be automatically set when HHL is executed using the dictionary approach and the input does not have dimension :math:`2^{n}`."
msgstr ""

#: ../../../aqua/algorithms.rst:784
msgid "An ``int`` value or ``None`` is epxected. The defult is ``None``."
msgstr ""

#: ../../../aqua/algorithms.rst:786
msgid "A Boolean indicating whether or not to truncate matrix and result vector to half the dimension by simply cutting off entries with other indices after the input matrix was expanded to be hermitian following"
msgstr ""

#: ../../../aqua/algorithms.rst:790
msgid "\\begin{pmatrix} 0 & A^\\mathsf{H}\\\\ A & 0 \\end{pmatrix}"
msgstr ""

#: ../../../aqua/algorithms.rst:797
msgid "where the conjugate transpose of matrix :math:`A` is denoted by :math:`A^\\mathsf{H}`. The truncation of the result vector is done by simply cutting off entries of the upper half. This parameter is set to ``True`` if HHL is executed using the dictionary approach and the input matrix is not hermitian."
msgstr ""

#: ../../../aqua/algorithms.rst:812
msgid "Consult the documentation on :ref:`iqfts`,  :ref:`initial-states`, :ref:`eigs`, :ref:`reciprocals` for more details. `The original paper is accessible on arxiv. <https://arxiv.org/abs/0811.3171>`__"
msgstr ""

#: ../../../aqua/algorithms.rst:815
msgid "HHL requires eigenvalue estimation using QPE (:ref:`eigs`), the eigenvalue inversion (:ref:`reciprocals`), and a matrix and initial state as part of its configuration."
msgstr ""

#: ../../../aqua/algorithms.rst:822
msgid "When referring to HHL declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``HHL``."
msgstr ""

#: ../../../aqua/algorithms.rst:827
msgid "In Aqua, HHL supports the ``linear_system`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:834
msgid "Shor's Factory Algorithm (Shor)"
msgstr ""

#: ../../../aqua/algorithms.rst:836
msgid "Shor's Factoring algorithm is one of the most well-known quantum algorithms. It takes advantage of :ref:`iqfts` circuits and finds the prime factors for input integer :math:`N` in polynomial time. The Shor's algorithm included in Aqua is adapted from `this implementation <https://github.com/ttlion/ShorAlgQiskit>`__."
msgstr ""

#: ../../../aqua/algorithms.rst:842
msgid "The input integer ``N`` (defaulted to 15 if omitted) to be factored is expected to be odd and greater than 2. Even though our implementation is general, its capability will be limited by the capacity of the simulator/hardware. Another input integer ``a`` (defaulted to 2 if omitted) can also be supplied, which needs to be a coprime smaller than ``N``."
msgstr ""

#: ../../../aqua/algorithms.rst:851
msgid "For more details, please see `this implementation <https://github.com/ttlion/ShorAlgQiskit>`__ and `this paper <https://arxiv.org/abs/quant-ph/0205095>`__."
msgstr ""

#: ../../../aqua/algorithms.rst:856
msgid "When referring to Shor's algorithm declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``Shor``."
msgstr ""

#: ../../../aqua/algorithms.rst:861
msgid "In Aqua, Shor's algorithm supports the ``factoring`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:867
msgid "Quantum Generative Adversarial Network(qGAN)"
msgstr ""

#: ../../../aqua/algorithms.rst:869
msgid "`qGAN <https://arxiv.org/abs/1904.00043>`__ is a hybrid quantum-classical algorithm used for generative modelling tasks. The qGAN implementation in Aqua requires the definition of a variational form for the implementation of a quantum generator and a PyTorch neural network for the implementation of a classical discriminator. These networks are trained in alternating optimization steps, where the discriminator tries to differentiate between training data samples and data samples from the generator and the generator aims at generating samples which the discriminator classifies as training data samples. Eventually, the quantum generator learns the training data's underlying probability distribution. The trained quantum generator loads a quantum state which is a model of the target distribution."
msgstr ""

#: ../../../aqua/algorithms.rst:884
msgid "#"
msgstr ""

#: ../../../aqua/algorithms.rst:886
msgid "In summary, qGAN can be configured with the following parameters:"
msgstr ""

#: ../../../aqua/algorithms.rst:888
msgid "An ``array`` indicating the numbers of qubits for d qubit registers, where d is dimension of the training data:"
msgstr ""

#: ../../../aqua/algorithms.rst:894
msgid "If no value for ``num_qubits`` is specified, the default is ``[3, 3, ..., 3]``."
msgstr ""

#: ../../../aqua/algorithms.rst:896
msgid "A positive ``int`` value configuring the batch size for batching the training data:"
msgstr ""

#: ../../../aqua/algorithms.rst:902
msgid "This has to be a positive ``int`` value.  The default is ``500``."
msgstr ""

#: ../../../aqua/algorithms.rst:904
msgid "A positive ``int`` value configuring the number of training epochs:"
msgstr ""

#: ../../../aqua/algorithms.rst:910
msgid "This has to be a positive ``int`` value.  The default is ``3000``."
msgstr ""

#: ../../../aqua/algorithms.rst:912
msgid "A positive ``int`` value configuring the seed for random values: .. code:: python"
msgstr ""

#: ../../../aqua/algorithms.rst:915
msgid "seed = 1 | 2 | ..."
msgstr ""

#: ../../../aqua/algorithms.rst:917
msgid "This has to be a positive ``int`` value.  The default is ``7``."
msgstr ""

#: ../../../aqua/algorithms.rst:921
msgid "An optional positive ``float`` value for setting a tolerance for relative entropy. If the training results in a state such that the relative entropy is smaller or equal than the given tolerance the training will halt."
msgstr ""

#: ../../../aqua/algorithms.rst:929
msgid "An optional ``str`` to give a directory where the parameters computed throughout the training shall be stored in CSV format."
msgstr ""

#: ../../../aqua/algorithms.rst:940
msgid "When referring to qGAN declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it is ``QGAN``."
msgstr ""

#: ../../../aqua/algorithms.rst:945
msgid "In Aqua, qGAN supports the ``distribution_learning_loading`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:956
msgid "Classical Reference Algorithms"
msgstr ""

#: ../../../aqua/algorithms.rst:958
msgid "In this section, we describe the classical algorithms currently available in Aqua. While these algorithms do not use a quantum device or simulator, and rely on purely classical approaches, they may be useful in the near term to generate reference values while experimenting with, developing and testing quantum algorithms."
msgstr ""

#: ../../../aqua/algorithms.rst:966
msgid "Aqua prevents associating a quantum device or simulator to any experiment that uses a classical algorithm.  The ``\"backend\"`` section of an experiment to be conducted via a classical algorithm is disabled."
msgstr ""

#: ../../../aqua/algorithms.rst:974
msgid "Exact Eigensolver"
msgstr ""

#: ../../../aqua/algorithms.rst:976
msgid "Exact Eigensolver computes up to the first :math:`k` eigenvalues of a complex-valued square matrix of dimension :math:`n \\times n`, with :math:`k \\leq n`. It can be configured with an ``int`` parameter ``k`` indicating the number of eigenvalues to compute:"
msgstr ""

#: ../../../aqua/algorithms.rst:986
msgid "Specifically, the value of this parameter must be an ``int`` value ``k`` in the range :math:`[1,n]`. The default is ``1``."
msgstr ""

#: ../../../aqua/algorithms.rst:991
msgid "When referring to Exact Eigensolver declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``ExactEigensolver``."
msgstr ""

#: ../../../aqua/algorithms.rst:996
msgid "In Aqua, Exact Eigensolver supports the ``energy``, ``ising`` and ``excited_states``  problems."
msgstr ""

#: ../../../aqua/algorithms.rst:1002
msgid "Exact LSsolver"
msgstr ""

#: ../../../aqua/algorithms.rst:1004
msgid "Exact LSsolver (linear system solver) computes the eigenvalues of a complex-valued square matrix :math:`A` of dimension :math:`n \\times n` and the solution to the systems of linear equations defined by :math:`A\\overrightarrow{x}=\\overrightarrow{b}` with input vector :math:`\\overrightarrow{b}`."
msgstr ""

#: ../../../aqua/algorithms.rst:1012
msgid "When referring to Exact LSsolver declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``ExactLSsolver``."
msgstr ""

#: ../../../aqua/algorithms.rst:1017
msgid "In Aqua, Exact LSsolver supports the ``linear_system`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:1023
msgid "CPLEX Ising"
msgstr ""

#: ../../../aqua/algorithms.rst:1025
msgid "This algorithm uses the `IBM ILOG CPLEX Optimization Studio <https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.studio.help/Optimization_Studio/topics/COS_home.html>`__, which should be installed along with its `Python API <https://www.ibm.com/support/knowledgecenter/SSSA5P_12.8.0/ilog.odms.cplex.help/CPLEX/GettingStarted/topics/set_up/Python_setup.html>`__ for this algorithm to be operational. This algorithm currently supports computing the energy of an Ising model Hamiltonian."
msgstr ""

#: ../../../aqua/algorithms.rst:1032
msgid "CPLEX Ising can be configured with the following parameters:"
msgstr ""

#: ../../../aqua/algorithms.rst:1034
msgid "A time limit in seconds for the execution:"
msgstr ""

#: ../../../aqua/algorithms.rst:1040
msgid "A positive ``int`` value is expected.  The default value is `600`."
msgstr ""

#: ../../../aqua/algorithms.rst:1042
msgid "The number of threads that CPLEX uses:"
msgstr ""

#: ../../../aqua/algorithms.rst:1048
msgid "A non-negative ``int`` value is expected. Setting ``thread`` to ``0`` lets CPLEX decide the number of threads to allocate, but this may not be ideal for small problems.  Any value greater than ``0`` specifically sets the thread count.  The default value is ``1``, which is ideal for small problems."
msgstr ""

#: ../../../aqua/algorithms.rst:1054
msgid "Decides what CPLEX reports to the screen and records in a log during mixed integer optimization (MIP)."
msgstr ""

#: ../../../aqua/algorithms.rst:1061
msgid "An ``int`` value between ``0`` and ``5`` is expected. The amount of information displayed increases with increasing values of this parameter. By default, this value is set to ``2``."
msgstr ""

#: ../../../aqua/algorithms.rst:1067
msgid "When referring to CPLEX Ising declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``CPLEX.Ising``."
msgstr ""

#: ../../../aqua/algorithms.rst:1072
msgid "In Aqua, CPLEX supports the ``ising`` problem."
msgstr ""

#: ../../../aqua/algorithms.rst:1078
msgid "Support Vector Machine Radial Basis Function Kernel (SVM Classical)"
msgstr ""

#: ../../../aqua/algorithms.rst:1080
msgid "SVM Classical uses a classical approach to experiment with feature map classification problems. SVM Classical can be configured with a ``bool`` parameter, indicating whether or not to print additional information when the algorithm is running:"
msgstr ""

#: ../../../aqua/algorithms.rst:1089
msgid "The default value for this parameter is ``False``."
msgstr ""

#: ../../../aqua/algorithms.rst:1093
msgid "When referring to SVM Classical declaratively inside Aqua, its code ``name``, by which Aqua dynamically discovers and loads it, is ``SVM``."
msgstr ""

#: ../../../aqua/algorithms.rst:1098
msgid "In Aqua, SVM Classical supports the ``classification`` problem."
msgstr ""

